/*
  Copyright (c) 2021 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/

struct VsIn2 {
    float2 position	: POSITION;
    float2 uv		: TEXCOORD0;
};
struct VsIn3 {
    float3 position	: POSITION;
    float3 Normal	: NORMAL;
    float3 Binormal	: BINORMAL;
    float3 Tangent	: TANGENT;
    float3 Color	: TEXCOORD0;
    float2 uv		: TEXCOORD1;
};
struct VsOut {
    float4 position	: POSITION;
    float2 uv		: TEXCOORD0;
};

[Vertex shader]
ROW_MAJOR 
float4x4 worldViewProj 
MVPSEMANTIC
;
VsOut main2(VsIn2 In)
{
	VsOut Out=(VsOut)0;
	Out.position = float4(In.position.x, In.position.y, 0.0 , 1.0);
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	return Out;
}
VsOut main3(VsIn3 In)
{
	VsOut Out=(VsOut)0;
	Out.position = mul(worldViewProj, float4(In.position, 1.0));
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	return Out;
}

[Fragment shader]
float2      iResolution=float2(1,1);                  // viewport iResolution (in pixels)
float     iTime=0;                        // shader playback iTime (in seconds)
float3      iMouse=float3(1,1,1);                       // iMouse pixel coords
sampler2D iChannel0;

#define SCALE 0.95
#define PI 3.1457

float map(float3 p) {
    float lat = 90. - acos(p.y / length(p)) * 180./PI;
    float lon = atan2(p.x, p.z) * 180./PI;
    float2 uv = float2(lon/360., lat/180.) + 0.5;
    return tex2D(iChannel0, uv).x;
}

float3 normal(float3 p) {
	float2 e = float2(1,0)/1e3;
    p += 0.01 * float3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx))/ (2. * length(e));
	return normalize(p);
}

float4 main(VsOut IN): COLOR
{
	float4 fragColor;
	float2 fragCoord=IN.uv;
    float2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;
    float lat = 15. * sin(0.1 * iTime);
    float lon = 7.5 * iTime + 100.;
    if (iMouse.z > 0.) {
        lat = 90.  - 180. * iMouse.y/iResolution.y;
        lon = 180. - 360. * iMouse.x/iResolution.x;
    }
    float3 camPos = 10. * float3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));
    float3 w = normalize(-camPos);
    float3 u = normalize(cross(w, float3(0,1,0)));
    float3 v = normalize(cross(u, w));
    float3x3 camera = float3x3(u, v, w);
    
    float3 dir = normalize(mul(camera, float3(p / SCALE, length(camPos))));
    float dist = iSphere(camPos, dir, float4(0,0,0,1));
    fragColor = float4(0,0,0,1);
    if (dist > 0.) {
        float3 q = camPos + dir * dist;
        float c = map(q);
        float3 n = normal(q);
        float light = clamp(dot(n, normalize(float3(-4,1,2))), 0., 1.);
        float heat = clamp(2. / pow(iTime, 2.), 0., 1.);
        fragColor = light * lerp(float4(0.58, 0.57, 0.55, 1), float4(0.15, 0.13, 0.1, 1), smoothstep(0., 3., c));
        fragColor += 5. * c * heat * float4(1., 0.15, 0.05, 1.);
    }
    fragColor.rgb = lerp(fragColor.rgb, float3(0,0,0), smoothstep(SCALE - 4./iResolution.y, SCALE + 1./iResolution.y, length(p)));
    fragColor.rgb = pow(fragColor.rgb, float3(1./2.2,1./2.2,1./2.2));
	return fragColor;
}

