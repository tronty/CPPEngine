/*
  Copyright (c) 2021 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/

struct VsIn2 {
    float2 position	: POSITION;
    float2 uv		: TEXCOORD0;
};
struct VsIn3 {
    float3 position	: POSITION;
    float3 Normal	: NORMAL;
    float3 Binormal	: BINORMAL;
    float3 Tangent	: TANGENT;
    float3 Color	: TEXCOORD0;
    float2 uv		: TEXCOORD1;
};
struct VsOut {
    float4 position	: POSITION;
    float2 uv		: TEXCOORD0;
	float3 normal   : TEXCOORD1;
	float  fog      : TEXCOORD2;
	float2 scale    : TEXCOORD3;
	float3 cubeCoord: TEXCOORD4;
};

float mod(float x, float y)
{
  return x - y * floor(x / y);
}

float2 mod(float2 x, float2 y)
{
  return x - y * floor(x / y);
}

float3 mod(float3 x, float3 y)
{
  return x - y * floor(x / y);
}

float3 camPos=float3(0.000000, 0.000000, 1.000000);
float pixel=0.001953;
float halfPixel=0.000977;
float scale = 10;

// https://www.shadertoy.com/view/4dlGW2

// Tileable noise, for creating useful textures. By David Hoskins, Sept. 2013.
// It can be extrapolated to other types of randomised texture.

#define SHOW_TILING
#define TILES 2.0 // Use 1.0 for normal tiling across whole texture.

//----------------------------------------------------------------------------------------
float Hash(in float2 p, in float scale)
{
	// This is tiling part, adjusts with the scale...
	p = mod(p, scale);
	return frac(sin(dot(p, float2(27.16898, 38.90563))) * 5151.5473453);
}

//----------------------------------------------------------------------------------------
float Noise(in float2 p, in float scale_ )
{
	float2 f;
	
	p *= scale_;

	
	f = frac(p);		// Separate integer from fractional
    p = floor(p);
	
    f = f*f*(3.0-2.0*f);	// Cosine interpolation approximation
	
    float res = lerp(lerp(Hash(p, 				 scale_),
						Hash(p + float2(1.0, 0.0), scale_), f.x),
					lerp(Hash(p + float2(0.0, 1.0), scale_),
						Hash(p + float2(1.0, 1.0), scale_), f.x), f.y);
    return res;
}

#if 0
//----------------------------------------------------------------------------------------
float fBm(in float2 p, in float scale_)
{
    p += float2(sin(iTime * .7), cos(iTime * .45))*(.1) + iMouse.xy*.1/iResolution.xy;
	float f = 0.0;
	// Change starting scale to any integer value...
	float scale = scale_;
    p = mod(p, scale);
	float amp   = 0.6;
	
	for (int i = 0; i < 5; i++)
	{
		f += Noise(p, scale) * amp;
		amp *= .5;
		// Scale must be multiplied by an integer value...
		scale *= 2.;
	}
	// Clamp it just in case....
	return min(f, 1.0);
}

float turb(float2 c, in float scale_){
	float t = 0.0;

	float k = 1.0;
	for (int i = 0; i < 4; i++){
		#if 0
		float n = tex2D(Noise, c).x;
		#else
		float n = Noise(c, scale_);
		#endif

		t += k * n;

		k /= 2.192038172;
		c *= 2.192038172;
	}

	return t;
}

#if 0
#define NOISE_SIZE 128	
float Height(float2 texCoord)
{
	return tileableNoise2(x * 0.143f, z * 0.143f, 0.143f * NOISE_SIZE, 0.143f * NOISE_SIZE); // ???
}
#endif
#endif

[Vertex shader]
#if 1
ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;
#else
float4x4 worldViewProj;
#endif
VsOut main2(VsIn2 In)
{
	VsOut Out=(VsOut)0;
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	//Out.texCoord = pos * 16.0;

	float2 texCoord = In.position.xy * float2(0.5, -0.5) + 0.5 + halfPixel;
	float2 texCoord0 = texCoord + float2( pixel, 0.0);
	float2 texCoord1 = texCoord + float2(-pixel, 0.0);
	float2 texCoord2 = texCoord + float2( 0.0,  pixel);
	float2 texCoord3 = texCoord + float2( 0.0, -pixel);
	float2 texCoord4 = texCoord;

	// Height = tileableNoise2(x * 0.143f, z * 0.143f, 0.143f * NOISE_SIZE, 0.143f * NOISE_SIZE);
	#if 1
	float height = Noise(texCoord, scale);	
	float height0 = Noise(texCoord0, scale).x;
	float height1 = Noise(texCoord1, scale).x;
	float height2 = Noise(texCoord2, scale).x;
	float height3 = Noise(texCoord3, scale).x;
	float height4 = Noise(texCoord4, scale).x;
	#else
	float height = turb(texCoord, scale);	
	float height0 = turb(texCoord0, scale).x;
	float height1 = turb(texCoord1, scale).x;
	float height2 = turb(texCoord2, scale).x;
	float height3 = turb(texCoord3, scale).x;
	float height4 = turb(texCoord4, scale).x;
	#endif
	float4 vertex = float4(In.position.x, height, In.position.y, 1.0);
	
	float3 tangent  = float3(0.004, height0 - height1, 0.0  );
	float3 binormal = float3(0.0,   height2 - height3, 0.004);
	float3 normal = -normalize(cross(tangent, binormal));
	Out.normal = vertex.xyz;
	Out.fog = saturate(0.65 * length(vertex.xyz - camPos));
	Out.scale = saturate(vertex.w * 1.2 - 0.3) * float2(0.6, 0.5);

	Out.position = mul(worldViewProj, vertex);
	// Nvidia seems to have some kind of weird precision problem here
	Out.position.z *= 0.99999;
	Out.cubeCoord = Out.position.xyz;
	return Out;
}
VsOut main3(VsIn3 In)
{
	VsOut Out=(VsOut)0;
	Out.position = mul(worldViewProj, float4(In.position, 1.0));
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	return Out;
}

[Fragment shader]

float3      iResolution=float3(1,1,1);                  // viewport resolution (in pixels)
float     iTime=0;                        // shader playback time (in seconds)
float4      iMouse=float4(1,1,1,1);                       // mouse pixel coords

//----------------------------------------------------------------------------------------
#if 0
float4 main(VsOut IN): COLOR 
{
	float4 fragColor;
	float2 fragCoord=IN.uv;
	float2 uv = fragCoord.xy / iResolution.xy;

	#ifdef SHOW_TILING
	uv *= TILES;
	#endif
	
	// Do the noise cloud (fractal Brownian motion)
	float bri = fBm(uv);
	
	bri = pow(bri, 1.2); // ...cranked up the contrast for demo.
	float3 col = float3(bri);
	
	#ifdef SHOW_TILING
	// Flash tile borders...
	float2 pixel = TILES / iResolution.xy;
	if (mod(iTime-2.0, 4.0) < 2.0)
	{
		float2 first 		= step(pixel, uv);
		uv  = step(frac(uv), pixel);	// Only add one line of pixels per tile.
		col = lerp(col, float3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);
	}
	#endif

	fragColor = float4(col,1.0);
	return fragColor;
}
#else

sampler2D Ground;
float3 lightDir=float3(0.000000, 0.600000, 0.800000);
float4 fogColor=float4(1.000000, 0.500000, 0.100000, 1.000000);
samplerCUBE Env;
float4 scaleBias=float4(0.003,-0.003,-1,1);

float4 main(VsOut IN): COLOR 
{
	float4 fragColor;
	float2 fragCoord=IN.uv;
	float2 uv = fragCoord.xy / iResolution.xy;
	float2 coord=uv;
	float4 fogColor_=fogColor;
#if 1
	float4 sky = texCUBE(Env, IN.cubeCoord);
	float fog = saturate(normalize(IN.cubeCoord).y * scaleBias.x + scaleBias.y);
	fog *= fog * (3 - 2 * fog);
	fogColor_=lerp(fogColor_, sky, fog);
#endif
#if 0
	float t = turb(coord);
	float3 p = float3(uv.x, t * t * 0.45, uv.y);
#else
	float diffuse = saturate(dot(lightDir, IN.normal) * IN.scale.x + IN.scale.y);
	#if 0
	float4 base = tex2D(Ground, uv);
	#else
	float4 base = float4(0,1,0,1);
	#endif
	return lerp(diffuse * base, fogColor_, IN.fog);
#endif
}
#endif

