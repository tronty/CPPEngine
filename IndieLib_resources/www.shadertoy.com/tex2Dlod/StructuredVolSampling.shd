/*
  Copyright (c) 2019 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/
struct VsIn {
    float3 position	: POSITION;
    float3 Normal	: NORMAL;
    float3 Binormal	: BINORMAL;
    float3 Tangent	: TANGENT;
    float3 Color	: TEXCOORD0;
    float2 uv		: TEXCOORD1;
};
struct VsOut {
    float4 position	: POSITION;
    float2 uv		: TEXCOORD0;
};

[Vertex shader]
ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;
VsOut main(VsIn In)
{
	VsOut Out=(VsOut)0;
	Out.position = mul(worldViewProj, float4(In.position, 1.0));
	Out.uv = In.uv;
	return Out;
}

[Fragment shader]
sampler2D iChannel0
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
//
// For diagram shader showing how samples are taken:
//
// https://www.shadertoy.com/view/ll3GWs
//
// We are in the process of writing up this technique. The following github repos
// is the home of this research.
//
// https://github.com/huwb/volsample
//
// 
//
// Additional credits - this scene is mostly mash up of these two amazing shaders:
//
// Clouds by iq: https://www.shadertoy.com/view/XslGRr
// Cloud Ten by nimitz: https://www.shadertoy.com/view/XtS3DD
// 

#define SAMPLE_COUNT 40
#define PERIOD 1.

// mouse toggle
int STRUCTURED;

// cam moving in a straight line
float3 sundir;

// LUT based 3d value noise_
float noise_( in float3 x )
{
    float3 p = floor(x);
    float3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    
    float2 uv = (p.xy+float2(37.0,17.0)*p.z) + f.xy;
    float2 rg = tex2Dlod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;
    return mix( rg.x, rg.y, f.z );
}


float4 map( in float3 p )
{
	float d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;

    float3 q = p;
    float f;
    
    f  = 0.5000*noise_( q ); q = q*2.02;
    f += 0.2500*noise_( q ); q = q*2.03;
    f += 0.1250*noise_( q ); q = q*2.01;
    f += 0.0625*noise_( q );
    d += 2.75 * f;

    d = clamp( d, 0.0, 1.0 );
    
    float4 res = float4( d );
    
    float3 col = 1.15 * float3(1.0,0.95,0.8);
    col += float3(1.,0.,0.) * exp2(res.x*10.-10.);
    res.xyz = mix( col, float3(0.7,0.7,0.7), res.x );
    
    return res;
}


// to share with unity hlsl
#define float2 float2
#define float3 float3
#define fmod mod
float mysign( float x ) { return x < 0. ? -1. : 1. ; }
float2 mysign( float2 x ) { return float2( x.x < 0. ? -1. : 1., x.y < 0. ? -1. : 1. ) ; }

// compute ray march start offset and ray march step delta and blend weight for the current ray
void SetupSampling( out float2 t, out float2 dt, out float2 wt, in float3 ro, in float3 rd )
{
    if( !STRUCTURED )
    {
        dt = float2(PERIOD,PERIOD);
        t = dt;
        wt = float2(0.5,0.5);
        return;
    }
    
    // the following code computes intersections between the current ray, and a set
    // of (possibly) stationary sample planes.
    
    // much of this should be more at home on the CPU or in a VS.
    
    // structured sampling pattern line normals
    float3 n0 = (abs( rd.x ) > abs( rd.z )) ? float3(1., 0., 0.) : float3(0., 0., 1.); // non diagonal
    float3 n1 = float3(mysign( rd.x * rd.z ), 0., 1.); // diagonal

    // normal lengths (used later)
    float2 ln = float2(length( n0 ), length( n1 ));
    n0 /= ln.x;
    n1 /= ln.y;

    // some useful DPs
    float2 ndotro = float2(dot( ro, n0 ), dot( ro, n1 ));
    float2 ndotrd = float2(dot( rd, n0 ), dot( rd, n1 ));

    // step size
    float2 period = ln * PERIOD;
    dt = period / abs( ndotrd );

    // dist to line through origin
    float2 dist = abs( ndotro / ndotrd );

    // raymarch start offset - skips leftover bit to get from ro to first strata lines
    t = -mysign( ndotrd ) * fmod( ndotro, period ) / abs( ndotrd );
    if( ndotrd.x > 0. ) t.x += dt.x;
    if( ndotrd.y > 0. ) t.y += dt.y;

    // sample weights
    float minperiod = PERIOD;
    float maxperiod = sqrt( 2. )*PERIOD;
    wt = smoothstep( maxperiod, minperiod, dt/ln );
    wt /= (wt.x + wt.y);
}

float4 raymarch( in float3 ro, in float3 rd )
{
    float4 sum = float4(0, 0, 0, 0);
    
    // setup sampling - compute intersection of ray with 2 sets of planes
    float2 t, dt, wt;
	SetupSampling( t, dt, wt, ro, rd );
    
    // fade samples at far extent
    float f = .6; // magic number - TODO justify this
    float endFade = f*float(SAMPLE_COUNT)*PERIOD;
    float startFade = .8*endFade;
    
    for(int i=0; i<SAMPLE_COUNT; i++)
    {
        if( sum.a > 0.99 ) continue;

        // data for next sample
        float4 data = t.x < t.y ? float4( t.x, wt.x, dt.x, 0. ) : float4( t.y, wt.y, 0., dt.y );
        // somewhat similar to: https://www.shadertoy.com/view/4dX3zl
        //float4 data = mix( float4( t.x, wt.x, dt.x, 0. ), float4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );
        float3 pos = ro + data.x * rd;
        float w = data.y;
        t += data.zw;
        
        // fade samples at far extent
        w *= smoothstep( endFade, startFade, data.x );
        
        float4 col = map( pos );
        
        // iqs goodness
        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );
        float3 lin = float3(0.51, 0.53, 0.63)*1.35 + 0.55*float3(0.85, 0.57, 0.3)*dif;
        col.xyz *= lin;
        
        col.xyz *= col.xyz;
        
        col.a *= 0.75;
        col.rgb *= col.a;

        // integrate. doesn't account for dt yet, wip.
        sum += col * (1.0 - sum.a) * w;
    }

    sum.xyz /= (0.001+sum.w);

    return clamp( sum, 0.0, 1.0 );
}

float3 sky( float3 rd )
{
    float3 col = float3(0.);
    
    float hort = 1. - clamp(abs(rd.y), 0., 1.);
    col += 0.5*float3(.99,.5,.0)*exp2(hort*8.-8.);
    col += 0.1*float3(.5,.9,1.)*exp2(hort*3.-3.);
    col += 0.55*float3(.6,.6,.9);
    
    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );
    col += .2*float3(1.0,0.3,0.2)*pow( sun, 2.0 );
    col += .5*float3(1.,.9,.9)*exp2(sun*650.-650.);
    col += .1*float3(1.,1.,0.1)*exp2(sun*100.-100.);
    col += .3*float3(1.,.7,0.)*exp2(sun*50.-50.);
    col += .5*float3(1.,0.3,0.05)*exp2(sun*10.-10.); 
    
    float ax = atan(rd.y,length(rd.xz))/1.;
    float ay = atan(rd.z,rd.x)/2.;
    float st = texture( iChannel0, float2(ax,ay) ).x;
    float st2 = texture( iChannel0, .25*float2(ax,ay) ).x;
    st *= st2;
    st = smoothstep(0.65,.9,st);
    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));
    
    return col;
}



float4 main(VsOut IN): COLOR 
{
	float4 fragColor;
	float2 fragCoord=IN.uv;
    // click mouse to use naive raymarching
    STRUCTURED = iMouse.z <= 0.;
    sundir = normalize(float3(-1.0,0.0,-1.));

    float2 q = fragCoord.xy / iResolution.xy;
    float2 p = -1.0 + 2.0*q;
    p.x *= iResolution.x/ iResolution.y;
    float2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;
   
    // camera
    float3 lookDir = float3(cos(.53*iTime),0.,sin(iTime));
    float3 camVel = float3(-20.,0.,0.);

    float3 ro = float3(0.,1.5,0.) + iTime*camVel;
    float3 ta = ro + lookDir; //float3(ro.x, ro.y, ro.z-1.);
    float3 ww = normalize( ta - ro);
    float3 uu = normalize(cross( float3(0.0,1.0,0.0), ww ));
    float3 vv = normalize(cross(ww,uu));
    float fov = 1.;
    float3 rd = normalize( fov*p.x*uu + fov*1.2*p.y*vv + 1.5*ww );
    
    // divide by forward component to get fixed z layout instead of fixed dist layout
    //float3 rd_layout = rd/mix(dot(rd,ww),1.0,samplesCurvature);
    float4 clouds = raymarch( ro, rd );
    
    float3 col = clouds.xyz;
        
    // sky if visible
    if( clouds.w <= 0.99 )
	    col = mix( sky(rd), col, clouds.w );
    
	col = clamp(col, 0., 1.);
    col = smoothstep(0.,1.,col);
	col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign
        
    fragColor = float4( col, 1.0 );
	return fragColor;
}

