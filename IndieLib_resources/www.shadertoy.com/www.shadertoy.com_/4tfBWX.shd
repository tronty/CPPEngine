/*
  Copyright (c) 2021 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/

struct VsIn2 {
    float2 position	: POSITION;
    float2 uv		: TEXCOORD0;
};
struct VsIn3 {
    float3 position	: POSITION;
    float3 Normal	: NORMAL;
    float3 Binormal	: BINORMAL;
    float3 Tangent	: TANGENT;
    float3 Color	: TEXCOORD0;
    float2 uv		: TEXCOORD1;
};
struct VsOut {
    float4 position	: POSITION;
    float2 uv		: TEXCOORD0;
};
[Vertex shader]
ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;
VsOut main2(VsIn2 In)
{
	VsOut Out=(VsOut)0;
	Out.position = float4(In.position.x, In.position.y, 0.0 , 1.0);
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	return Out;
}
VsOut main3(VsIn3 In)
{
	VsOut Out=(VsOut)0;
	Out.position = mul(worldViewProj, float4(In.position, 1.0));
	Out.uv.x = In.uv.x;Out.uv.y = 1.0-In.uv.y;
	return Out;
}

[Fragment shader]
float iTime=0;
float2 iResolution=float2(1,1);
/**
 * Drawing Sierpinsky traingles using the Chaos Game.
 *
 * Inspired by: https://www.quora.com/What-are-some-mind-blowing-facts-that-sound-like-BS-but-are-actually-true/answer/David-Prifti-1
 *
 * Rules:
 *
 * - The three points of the triangle are points A, B and C
 * - Choose a random starting point
 * - For every iteration, randomly choose point A, B or C.
 *   Move half way from the last point to that point.
 */

// Radius of points being drawn
float RADIUS = 1.0;

// Offset from image border
float OFFSET = 10.0;

// Seed for hash function
float2 SEED = float2(0.5, 0.7);

// Speed: Number of points per second
float SPEED = 50.0;

// Starting points
#define A scale(float2(0.5, 1.0))
#define B scale(float2(1.0, 0.0))
#define C scale(float2(0.0, 0.0))

/**
 * Scale coordinates between 0.1 to the output image resolution, with the specified border offset.
 */
float2 scale(float2 coords) {
	return coords * (iResolution.xy - OFFSET * 2.0) + OFFSET;
}

/**
 * Return whether the `fragCoord` pair is within `RADIUS` of `point`.
 */
bool isPixel(float2 fragCoord, float2 Point) {
	return distance(fragCoord, Point) < RADIUS;
}

/**
 * Random function from http://shadertoy.wikia.com/wiki/Noise
 */
float2 rand(float2 p) {
    return frac(sin(float2(dot(p,float2(127.1,311.7)),dot(p,float2(269.5,183.3))))*43758.5453);
}

/**
 * Randomly choose a point A, B or C with 1/3 probability.
 */
float2 randABC(float2 seed) {
    float2 r = rand(seed);
    if (r.x < (1.0/3.0)) {
        return A;
    } else if (r.x < (1.0/3.0*2.0)) {
    	return B;
    } else {
        return C;
    }
}

/**
 * Return whether the `fragCoord` coordinate pair is a valid point in the
 * sequence of points derived from the `start` point.
 */
bool validPoint(float2 fragCoord, float2 start) {
    int iteration = int(iTime * SPEED); // Add 1 point per second
    
    if (isPixel(fragCoord, start)) {
        return true;
    }
    
    // We start at the starting point
    float2 currentPoint = start;
    
    // Increment every second
    for (int i = 0; i < iteration; i++) {
        // First, derive a different seed for each iteration.
        float2 seed = float2(float(i) * 0.001, float(i) * 0.002 / 3.0);
        float2 targetPoint = randABC(seed);
        currentPoint = currentPoint + ((targetPoint - currentPoint) / 2.0);
        if (isPixel(fragCoord, currentPoint)) {
        	return true;
        }
    }
    
    return false;
}

float4 main(in float2 fragCoord:TEXCOORD0) : COLOR
{
    float4 red = float4(1.0, 0.0, 0.0, 1.0);
    float4 white = float4(1.0, 1.0, 1.0, 1.0);
    float4 black = float4(0.0, 0.0, 0.0, 1.0);
    float4 color = float4(fragCoord.xy / iResolution.xy * 1.4, 1.0, 1.0); // Nicer colors depending on XY coords

    // Random starting point
    float2 R = scale(rand(SEED));
        
    // Determine whether this is a start point
    bool isStartPoint =
        isPixel(fragCoord, A) ||
        isPixel(fragCoord, B) ||
        isPixel(fragCoord, C);
    
    // Determine whether this is a valid point (depending on time)
    bool isValidPoint =
        validPoint(fragCoord, R);
        
    float4 fragColor;
    if (isStartPoint) {
    	fragColor = red;
    } else if (isValidPoint) {
        fragColor = color;
    } else {
        fragColor = black;
    }
    return fragColor;
}
