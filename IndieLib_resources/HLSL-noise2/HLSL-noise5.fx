float noiseScale
<
    string UIWidget = "slider";
    string UIName = "noise scale";
    float UIMin = 0.0; float UIMax = 20.0; float UIStep = 0.01;
> = 5.0;

// Generated by "vnoise_init.pl"
//	Generator $Revision: #3 $
// HLSL Noise Table
//	Seed value: 0
//

#define BSIZE 32
#define FULLSIZE 66
#define NOISEFRAC 0.03125

const float4 NTab[FULLSIZE] <string UIWdget="None";> = {
		-0.569811,0.432591,-0.698699,0,
		0.78118,0.163006,0.60265,1,
		0.436394,-0.297978,0.848982,2,
		0.843762,-0.185742,-0.503554,3,
		0.663712,-0.68443,-0.301731,4,
		0.616757,0.768825,0.168875,5,
		0.457153,-0.884439,-0.093694,6,
		-0.956955,0.110962,-0.268189,7,
		0.115821,0.77523,0.620971,8,
		-0.716028,-0.477247,-0.50945,9,
		0.819593,-0.123834,0.559404,10,
		-0.522782,-0.586534,0.618609,11,
		-0.792328,-0.577495,-0.196765,12,
		-0.674422,0.0572986,0.736119,13,
		-0.224769,-0.764775,-0.60382,14,
		0.492662,-0.71614,0.494396,15,
		0.470993,-0.645816,0.600905,16,
		-0.19049,0.321113,0.927685,17,
		0.0122118,0.946426,-0.32269,18,
		0.577419,0.408182,0.707089,19,
		-0.0945428,0.341843,-0.934989,20,
		0.788332,-0.60845,-0.0912217,21,
		-0.346889,0.894997,-0.280445,22,
		-0.165907,-0.649857,0.741728,23,
		0.791885,0.124138,0.597919,24,
		-0.625952,0.73148,0.270409,25,
		-0.556306,0.580363,0.594729,26,
		0.673523,0.719805,0.168069,27,
		-0.420334,0.894265,0.153656,28,
		-0.141622,-0.279389,0.949676,29,
		-0.803343,0.458278,0.380291,30,
		0.49355,-0.402088,0.77119,31,
		-0.569811,0.432591,-0.698699,0,
		0.78118,0.163006,0.60265,1,
		0.436394,-0.297978,0.848982,2,
		0.843762,-0.185742,-0.503554,3,
		0.663712,-0.68443,-0.301731,4,
		0.616757,0.768825,0.168875,5,
		0.457153,-0.884439,-0.093694,6,
		-0.956955,0.110962,-0.268189,7,
		0.115821,0.77523,0.620971,8,
		-0.716028,-0.477247,-0.50945,9,
		0.819593,-0.123834,0.559404,10,
		-0.522782,-0.586534,0.618609,11,
		-0.792328,-0.577495,-0.196765,12,
		-0.674422,0.0572986,0.736119,13,
		-0.224769,-0.764775,-0.60382,14,
		0.492662,-0.71614,0.494396,15,
		0.470993,-0.645816,0.600905,16,
		-0.19049,0.321113,0.927685,17,
		0.0122118,0.946426,-0.32269,18,
		0.577419,0.408182,0.707089,19,
		-0.0945428,0.341843,-0.934989,20,
		0.788332,-0.60845,-0.0912217,21,
		-0.346889,0.894997,-0.280445,22,
		-0.165907,-0.649857,0.741728,23,
		0.791885,0.124138,0.597919,24,
		-0.625952,0.73148,0.270409,25,
		-0.556306,0.580363,0.594729,26,
		0.673523,0.719805,0.168069,27,
		-0.420334,0.894265,0.153656,28,
		-0.141622,-0.279389,0.949676,29,
		-0.803343,0.458278,0.380291,30,
		0.49355,-0.402088,0.77119,31,
		-0.569811,0.432591,-0.698699,0,
		0.78118,0.163006,0.60265,1};

///////////////////////////// eof ///

///////////// functions 

// this is the smoothstep function f(t) = 3t^2 - 2t^3, without the normalization
float3 s_curve(float3 t) { return t*t*( float3(3,3,3) - float3(2,2,2)*t); }
float2 s_curve(float2 t) { return t*t*( float2(3,3) - float2(2,2)*t); }
float  s_curve(float  t) { return t*t*(3.0-2.0*t); }

// 3D version
float noise(float3 v, const uniform float4 pg[FULLSIZE])
{
    v = v + (10000.0f).xxx;   // hack to avoid negative numbers

    float3 i = frac(v * NOISEFRAC) * BSIZE;   // index between 0 and BSIZE-1
    float3 f = frac(v);            // fractional position

    // lookup in permutation table
    float2 p;
    p.x = pg[ i[0]     ].w;
    p.y = pg[ i[0] + 1 ].w;
    p = p + i[1];

    float4 b;
    b.x = pg[ p[0] ].w;
    b.y = pg[ p[1] ].w;
    b.z = pg[ p[0] + 1 ].w;
    b.w = pg[ p[1] + 1 ].w;
    b = b + i[2];

    // compute dot products between gradients and vectors
    float4 r;
    r[0] = dot( pg[ b[0] ].xyz, f );
    r[1] = dot( pg[ b[1] ].xyz, f - float3(1.0f, 0.0f, 0.0f) );
    r[2] = dot( pg[ b[2] ].xyz, f - float3(0.0f, 1.0f, 0.0f) );
    r[3] = dot( pg[ b[3] ].xyz, f - float3(1.0f, 1.0f, 0.0f) );

    float4 r1;
    r1[0] = dot( pg[ b[0] + 1 ].xyz, f - float3(0.0f, 0.0f, 1.0f) );
    r1[1] = dot( pg[ b[1] + 1 ].xyz, f - float3(1.0f, 0.0f, 1.0f) );
    r1[2] = dot( pg[ b[2] + 1 ].xyz, f - float3(0.0f, 1.0f, 1.0f) );
    r1[3] = dot( pg[ b[3] + 1 ].xyz, f - float3(1.0f, 1.0f, 1.0f) );

    // interpolate
    f = s_curve(f);
    r = lerp( r, r1, f[2] );
    r = lerp( r.xyyy, r.zwww, f[1] );
    return lerp( r.x, r.y, f[0] );
}

// 2D version
float noise(float2 v, const uniform float4 pg[FULLSIZE])
{
    v = v + (10000.0f).xx;

    float2 i = frac(v * NOISEFRAC) * BSIZE;   // index between 0 and BSIZE-1
    float2 f = frac(v);            // fractional position

    // lookup in permutation table
    float2 p;
    p[0] = pg[ i[0]   ].w;
    p[1] = pg[ i[0]+1 ].w;
    p = p + i[1];

    // compute dot products between gradients and vectors
    float4 r;
    r[0] = dot( pg[ p[0] ].xy,   f);
    r[1] = dot( pg[ p[1] ].xy,   f - float2(1.0f, 0.0f) );
    r[2] = dot( pg[ p[0]+1 ].xy, f - float2(0.0f, 1.0f) );
    r[3] = dot( pg[ p[1]+1 ].xy, f - float2(1.0f, 1.0f) );

    // interpolate
    f = s_curve(f);
    r = lerp( r.xyyy, r.zwww, f[1] );
    return lerp( r.x, r.y, f[0] );
}

// 1D version
float noise(float v, const uniform float4 pg[FULLSIZE])
{
    v = v + 10000.0f;

    float i = frac(v * NOISEFRAC) * BSIZE;   // index between 0 and BSIZE-1
    float f = frac(v);            // fractional position

    // compute dot products between gradients and vectors
    float2 r;
    r[0] = pg[i].x * f;
    r[1] = pg[i + 1].x * (f - 1.0f);

    // interpolate
    f = s_curve(f);
    return lerp( r[0], r[1], f);
}
//float r=noise(float3 v, NTab);
float fBm(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float freq = 1.0, amp = 0.5;
	float sum = 0;	
	for(int i=0; i<octaves; i++) {
		sum += noise(p*freq,NTab)*amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}
//define ssnoise(x) ((2*noise(x,NTab))-1)
#define ssnoise(x) noise(x,NTab)

float turbulence(int octaves, float3 P, float lacunarity, float gain)
{
  float sum = 0;
  float scale = 1;
  float totalgain = 1;
  for(int i=0;i<octaves;i++){
    sum += totalgain*ssnoise(P*scale);
    scale *= lacunarity;
    totalgain *= gain;
  }
  return abs(sum);
}

struct VS_INPUT
{
    float3 position	: POSITION;
    float3 normal	: NORMAL;
    float3 Binormal	: BINORMAL;
    float3 Tangent	: TANGENT;
    float3 Color	: TEXCOORD0;
    float2 texture0	: TEXCOORD1;
};

struct VS_OUTPUT
{
    float4 hposition : POSITION;
	float2 v_texCoord2D  : TEXCOORD0;
	float3 v_texCoord3D  : TEXCOORD1;
	float4 color	 : COLOR0;
};

struct PS_OUTPUT
{
	float4 color : COLOR;
};

ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;
float time;

/*
 * Both 2D and 3D texture coordinates are defined, for testing purposes.
 */

VS_OUTPUT mainVS( const VS_INPUT IN)
{
    VS_OUTPUT OUT;

	OUT.hposition = mul( modelViewProjection, float4(IN.position, 1) );

	OUT.v_texCoord2D = IN.texture0.xy;

	OUT.v_texCoord3D = IN.position.xyz;

	OUT.color = float4(0,1,0,1);//IN.color;

	return OUT;

}

PS_OUTPUT mainPS( VS_OUTPUT IN )
{
    PS_OUTPUT OUT;

  /* These lines test, in order, 2D classic noise, 2D simplex noise,
   * 3D classic noise, 3D simplex noise, 4D classic noise, and finally
   * 4D simplex noise.
   * Everything but the 4D simpex noise will make some uniform
   * variables remain unused and be optimized away by the compiler,
   * so OpenGL will fail to bind them. It's safe to ignore these
   * warnings from the C program. The program is designed to work anyway.
   */
   float n = 0;
  //float n = noise(IN.v_texCoord2D * 32.0 + 240.0);
  //float n = snoise(IN.v_texCoord2D * 16.0);
  //float n = noise(float3(4.0 * IN.v_texCoord3D.xyz * (2.0 + sin(0.5 * time))));
//if(NoiseTechnique==1)
  n = ssnoise(float3(2.0 * IN.v_texCoord3D.xyz * noiseScale * (2.0 + sin(0.5 * time))));
/*else //if(NoiseTechnique==4)
  n = ssnoise(float3(2.0 * IN.v_texCoord3D.xyz * (2.0 + sin(0.5 * time))));
  */
  //float n = noise(float4(8.0 * IN.v_texCoord3D.xyz, 0.5 * time));
  //float n = snoise(float4(4.0 * IN.v_texCoord3D.xyz, 0.5 * time));

  OUT.color = IN.color * float4(0.5 + 0.5 * float3(n, n, n), 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;
}
#if 0
PS_OUTPUT fragmentShaderPNoise(VS_OUTPUT IN)
{

  PS_OUTPUT OUT;

  IN.v_texCoord3D=float3(IN.v_texCoord2D, 0);

  float n = ssnoise(float3(4.0 * IN.v_texCoord3D.xyz));
  OUT.color = float4(0.5 + 0.85 * float3(n, n, n), 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;


}
PS_OUTPUT fragmentShaderWood(VS_OUTPUT IN)
{
  PS_OUTPUT OUT;

  IN.v_texCoord3D=float3(IN.v_texCoord2D, 0);

  float3 color1 = float3(0.658, 0.356, 0.0588);
  float3 color2 = float3(0.952, 0.713, 0.470);


  float x_v=IN.v_texCoord3D.x*0.6;
  float y_v=IN.v_texCoord3D.y*0.6;
  float z_v=IN.v_texCoord3D.z*0.6;

  float3 t1=float3(x_v*2,y_v*2,z_v*2);
  float3 t11=float3(x_v*2+1,y_v*2+1,z_v*2+1);
  float3 t2=float3(x_v*0,y_v*0,z_v*0);

  float temp_x=60*ssnoise(t1);
  float temp_y=60*ssnoise(t2);

  x_v=x_v-temp_x;
  y_v=y_v-temp_y;

  float3 diffuse=lerp(color1, color2, pow(cos(sqrt(x_v*x_v+y_v*y_v)+30*turbulence(68, t2, 2, 0.6))*0.5+0.5,3));
  OUT.color = float4(diffuse, 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;


}
PS_OUTPUT fragmentShaderMarble(VS_OUTPUT IN)
{
  PS_OUTPUT OUT;

  IN.v_texCoord3D=float3(IN.v_texCoord2D, 0);

  float3 color1 = float3(0.1f, 0.8f, 0.2);
  float3 color2 = float3(0.8f, 0.8, 0.8f);

  float3 diffuse=lerp(color1, color2, cos(IN.v_texCoord3D.z*0.1+6*turbulence(5,IN.v_texCoord3D.xyz,2,0.6)));
  OUT.color = float4(diffuse, 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;

}
PS_OUTPUT fragmentShaderFur(VS_OUTPUT IN)
{
  PS_OUTPUT OUT;

  IN.v_texCoord3D=float3(IN.v_texCoord2D, 0);

  float3 color1 = float3(0.8, 0.7, 0.0);
  float3 color2 = float3(0.6, 0.1, 0.0);

  float3 diffuse=lerp(color1, color2, clamp(0.7*turbulence(6,IN.v_texCoord3D.xyz,3,0.9), 0,1));

  OUT.color = float4(diffuse, 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;

}
PS_OUTPUT fragmentShaderCloud(VS_OUTPUT IN)
{
  PS_OUTPUT OUT;

  IN.v_texCoord3D=float3(IN.v_texCoord2D, 0);

  float3 color1 = float3(0.1f, 0.1f, 0.99);
  float3 color2 = float3(0.8f, 0.8, 0.8f);

  float3 diffuse=lerp(color1, color2, cos(IN.v_texCoord3D.z*0.5+2*turbulence(6,IN.v_texCoord3D.xyz,2,0.5))*0.9);
  OUT.color = float4(diffuse, 1.0);
  OUT.color=GammaCorrect4(OUT.color);
  return OUT;


}
       
#define TextureMatrix modelViewProjection
float Displacement=0.5;

[Vertex shader]
VS_OUTPUT main( VS_INPUT IN )
{
	VS_OUTPUT OUT=(VS_OUTPUT)0;
    float4 noisePos = mul(TextureMatrix/*[0]*/ , float4(IN.position,1));

    float i = (ssnoise(noisePos.xyz/*, pg*/) + 1.0) * 0.5;
    OUT.color = float4(i, i, i, 1.0);

    // displacement along normal
    float4 position = float4(IN.position,1) + (float4(IN.normal, 1.0) * i * Displacement);
    //float4 position = IN.position + (IN.normal * i * Displacement);
    position.w = 1.0;

    OUT.hposition = mul(modelViewProjection , position);
    return OUT;
};
[Fragment shader]
PS_OUTPUT main( VS_OUTPUT IN )
{
	PS_OUTPUT OUT;

	OUT.color = IN.color;
  OUT.color=GammaCorrect4(OUT.color);
	return OUT;
};
#endif
VS_OUTPUT VertexShaderFunction(VS_INPUT input)
{
	VS_OUTPUT OUT=(VS_OUTPUT)0;

    // calc the height displacement using 12 octaves of fBm
    float heightValue = fBm(input.position.xyz, 12);
    
    // add the height displacement to the vertex position
    input.position.xyz = input.position.xyz + heightValue;
    
    OUT.hposition = mul(modelViewProjection , float4(input.position,1));

    return OUT;
}

/*
//------------------------------------
vertexOutput VS(vertexInput IN)
{
    vertexOutput OUT;
    OUT.hPosition = mul(IN.position, worldViewProj);
    OUT.texcoord = IN.texcoord * noiseScale;
    OUT.wPosition = mul(IN.position, world).xyz * noiseScale;
    return OUT;
}

//-----------------------------------
float4 PS_inoise(vertexOutput IN): COLOR
{
	float3 p = IN.wPosition;
//	return abs(inoise(p));
//	return inoise(p);
	return inoise(p)*0.5+0.5;
//	return inoise(float3(IN.texcoord, 0.0))*0.5+0.5;
}
*/

