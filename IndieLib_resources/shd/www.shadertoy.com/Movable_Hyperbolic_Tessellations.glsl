uniform sampler2D iChannel0;

float e=2.718281828;
float sinh(float x)
{
	return (pow(e,x)-pow(e,-x))/2.0;
}
float cosh(float x)
{
	return (pow(e,x)+pow(e,-x))/2.0;
}
float acosh(float x)
{
	return log(x+sqrt(pow(x,2.0)-1.0));
}
float tanh(float x)
{
	return sinh(x)/cosh(x);
}

// Color schemes:
// 0 is "wireframe",
// 1 is alternating colors,
// 2 is a texture generated by the function "tex" (generates the flowers you see),
// 3 is the texture in iChannel0.
// There is an add-on for Firefox and Chrome that allows you to use custom textures.
// You can make some really nice faux Escher tilings with that.
#define COLOR_SCHEME 2

// Any whole numbers whose reciprocals sum to less than 1 can be chosen
#define P 2.0
#define Q 3.0
#define R 7.0

// Uncomment to see the Beltrami or upper half plane models instead
//#define BELTRAMI
//#define UPPER_HALF_PLANE

// Multisampling with SAMPLES^2 samples
#define SAMPLES 2

// Uncomment to show the edges of the triangles
#define EDGE_OVERLAY
#define EDGE_THICKNESS 0.002

// -------------------------------------------------------------------------------------

#define PI 3.141592653
#define MAX_ITER 100

// Complex number functions
vec2 conj(vec2 a){
    return vec2(a.x,-a.y);
}

vec2 comp_mul(vec2 a, vec2 b){
    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
}

vec2 comp_inv(vec2 a){
    return vec2(a.x, -a.y) / dot(a,a);
}

vec2 comp_div(vec2 a, vec2 b){
    return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y));
}


// There is a unique hyperbolic translation that takes m to the origin.
// This function applies that translation to p.
vec2 map_to_origin(vec2 m, vec2 p){
    
    return comp_div(p-m, comp_mul(-conj(m), p) + vec2(1.0,0.0));
}

vec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){
    
    float det = d2.x*d1.y - d1.x*d2.y;
    if(det == 0.0){
        return vec2(0.0);
    }
    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;
    float l1 = det1 / det;
    return P1 + l1*d1;
}

// compute the circle (center and radius) corresponding to the hyperbolic line through a and b
vec3 hyp_line_circle(vec2 a, vec2 b){
    vec2 a1 = comp_inv(conj(a));
    vec2 b1 = comp_inv(conj(b));
    
    vec2 p1 = 0.5*(a+a1);
    vec2 p2 = 0.5*(b+b1);
    
    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));
    float r = length(a - c);
    return vec3(c,r);
}


bool euclidean_line_side(vec2 p, vec2 a, vec2 b){
    vec2 n = vec2(-(b-a).y, (b-a).x);
    return dot(n,p-a) < 0.0;
}

bool hyperbolic_line_side(vec2 p, vec2 a, vec2 b){
    if(a == vec2(0.0)){
        return euclidean_line_side(p,b,vec2(0.0,0.0));
    }
    vec3 circle = hyp_line_circle(a,b);
    return length(p - circle.xy) < circle.z;
}

float line_dist(vec2 p, vec2 a, vec2 b){
    
    vec2 d = p - a;
    vec2 l = normalize(b-a);
    return length(d - dot(d,l)*l);
}

float circle_dist(vec2 p, vec3 circle){
    vec2 d = p - circle.xy;
    return length(d) - circle.z; 
}


vec2 circle_inversion(vec2 p, vec2 c, float r){
    return r*r*comp_inv(conj(p-c)) + c;
}

vec2 euclidean_reflection(vec2 p, vec2 a, vec2 b){
    vec2 n = vec2(-(b-a).y, (b-a).x);
    n = normalize(n);
    return p - 2.0*dot(p-a,n)*n;
}

vec2 beltrami_to_poincare(vec2 p){
    float z = sqrt(1.0 - dot(p,p));
    float alpha = 1.0/(z+1.0);
    return alpha * p;
}

vec2 upper_half_plane_to_poincare(vec2 p){
    p += vec2(0.0,1.0);
    return comp_div(p - vec2(0.0,1.0), p + vec2(0.0,1.0));
}

vec4 tex( vec2 uv )
{
    uv.y /= 2.0;
    
    vec4 color;
    
    color = vec4(0.5,1.0,0.5,1.0);
    
    if(length(uv - vec2(0.5, -0.3)) <= 0.58){
        color = vec4(0.0,0.0,0.0,1.0);
    }
    
    if(length(uv - vec2(0.5, -0.3)) <= 0.5){
        color = vec4(1.0,0.0,0.0,1.0);
    }
    if(length(uv) <= 0.15){
        color = vec4(1.0, 1.0, 0.0, 1.0);
    }
    return color;
}

vec4 shader(vec2 uv){

    vec2 coords = 2.0*uv-vec2(1.0);
    coords.x *= iResolution.x / iResolution.y;

#ifndef UPPER_HALF_PLANE
    if(length(coords) >= 1.0){
        return vec4(0.2, 0.0, 0.2, 1.0);
    }
#endif

    vec2 mouse = iMouse.xy / iResolution.xy;
    mouse = 2.0*mouse - vec2(1.0);
    mouse.x *= iResolution.x / iResolution.y;
    
#ifdef BELTRAMI
    coords = beltrami_to_poincare(coords);
    mouse = beltrami_to_poincare(mouse);
#endif

#ifdef UPPER_HALF_PLANE
    coords = upper_half_plane_to_poincare(coords);
    mouse = upper_half_plane_to_poincare(mouse);
#endif

    if(length(mouse) < 1.0){
        coords = map_to_origin(mouse,coords);
    }
    
    // compute two side lengths of the fundamental triangle using the hyperbolic law of cosines
    float s1 = tanh(0.5*acosh((cos(PI/P) + cos(PI/Q)*cos(PI/R)) / (sin(PI/Q)*sin(PI/R))));
    float s2 = tanh(0.5*acosh((cos(PI/Q) + cos(PI/P)*cos(PI/R)) / (sin(PI/P)*sin(PI/R))));
    
    // one vertex of the triangle is always set to be the origin, so that two of the sides are straight lines
    vec2 a = vec2(0.0, 0.0);
    vec2 b = vec2(s1, 0.0);
    mat2 rot = mat2(vec2(cos(PI/R), sin(PI/R)), vec2(-sin(PI/R), cos(PI/R)));
    vec2 c = rot*vec2(s2, 0.0);
    
    bool inside;
    int iter = 0;
    
    vec3 circle = hyp_line_circle(b, c);
    
    while(true){
    
        inside = true;

        if(hyperbolic_line_side(coords, c,b)){
            coords = circle_inversion(coords, circle.xy, circle.z);
            inside = false;
            iter++;
        }
        
        if(euclidean_line_side(coords, c,a)){
            coords = euclidean_reflection(coords, c,a);
            inside = false;
            iter++;
        }
        
        if(euclidean_line_side(coords, a,b)){
            coords = euclidean_reflection(coords, a,b);
            inside = false;
            iter++;
        }
      
        if(inside || iter > MAX_ITER){
            break;
        }
    }
    
    if(COLOR_SCHEME == 0){
        if(    line_dist(coords, c,a) <= EDGE_THICKNESS
            || line_dist(coords, b,a) <= EDGE_THICKNESS
            || circle_dist(coords, circle) <= EDGE_THICKNESS){
                   return vec4(0.0, 0.0, 0.0, 1.0);
        }
    
        return vec4(1.0);
    }
    
    vec4 color;
    
    if(COLOR_SCHEME == 1){
        if((mod(float(iter) , 2.0)) == 1.0){
            color = vec4(1.0, 0.0, 0.0, 1.0);
        } else {
            color = vec4(1.0);
        }
    }
    
    vec2 tex_coords;
    
    // scale texture coordinates so that maximum x and y coordinates are 1
    tex_coords.x = coords.x / s1;
    
    // do some trig to figure out the height of the fundamental triangle
    float s3 = sqrt(s1*s1 + s2*s2 - 2.0*s1*s2*cos(PI/R));
    float s4 = (s1+s2+s3)/2.0;
    float area = sqrt(s4*(s4-s1)*(s4-s2)*(s4-s3));
    float height = 2.0 * area / s1;
    
    tex_coords.y = coords.y / height;
    
    if(COLOR_SCHEME == 2){
        color = tex(tex_coords);
    }
    
    if(COLOR_SCHEME == 3){
        color = texture2D(iChannel0,tex_coords);
    }
    
#ifdef EDGE_OVERLAY
    if(   line_dist(coords, c,a) <= EDGE_THICKNESS
       || line_dist(coords, b,a) <= EDGE_THICKNESS
       || circle_dist(coords, circle) <= EDGE_THICKNESS){
                   color = vec4(0.0, 0.0, 0.0, 1.0);
    }
#endif    
    return color;
}

void main( )
{
    vec2 uv = xlv_TEXCOORD0.xy/iResolution.xy;
    vec2 pixel_size = vec2(1.0/iResolution.x,1.0/iResolution.y);
    uv -= pixel_size / 2.0;
    vec2 pixel_inc = pixel_size / float(SAMPLES+1);
    vec4 color = vec4(0.0);
    for(int i = 1; i <= SAMPLES; i++){
        for(int j = 1; j <= SAMPLES; j++){
            color += shader(uv + float(i)*pixel_inc.x + float(j)*pixel_inc.y);
        }
    }
    
    gl_FragColor = color/float(SAMPLES * SAMPLES);
    
}
