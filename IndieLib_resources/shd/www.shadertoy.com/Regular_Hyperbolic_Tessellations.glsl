uniform sampler2D iChannel0;
// Color schemes:
// 0 is "wireframe",
// 1 is a texture generated by the function "tex" (generates the effect you see by default),
// 2 is the texture in iChannel0.
// There is an add-on for Firefox and Chrome that allows you to use custom textures.
// You can make some really nice faux Escher tilings with that.
#define COLOR_SCHEME 1

// The Schläfli symbol of the tessellation.
// P is the number of sides of the polygon and Q is the number of polygons meeting at each vertex.
// As long as 1/P + 1/Q < 1/2 the tiling will exist.
#define P 7
#define Q 3

// Uncomment to see the Beltrami or upper half plane models instead
//#define BELTRAMI
//#define UPPER_HALF_PLANE

// Multisampling with SAMPLES^2 samples
#define SAMPLES 2

// Uncomment to show the edges of the polygons
#define EDGE_OVERLAY
#define EDGE_THICKNESS 0.01

// -------------------------------------------------------------------------------------

#define PI 3.141592653
#define MAX_ITER 100

// Complex number functions
vec2 conj(vec2 a){
    return vec2(a.x,-a.y);
}

vec2 comp_mul(vec2 a, vec2 b){
    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
}

vec2 comp_inv(vec2 a){
    return vec2(a.x, -a.y) / dot(a,a);
}

vec2 comp_div(vec2 a, vec2 b){
    return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y));
}


// There is a unique hyperbolic translation that takes m to the origin.
// This function applies that translation to p.
vec2 map_to_origin(vec2 m, vec2 p){
    return comp_div(p-m, comp_mul(-conj(m), p) + vec2(1.0,0.0));
}

vec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){
    float det = d2.x*d1.y - d1.x*d2.y;
    if(det == 0.0){
        return vec2(0.0);
    }
    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;
    float l1 = det1 / det;
    return P1 + l1*d1;
}

// compute the circle (center and radius) corresponding to the hyperbolic line through a and b
vec3 hyp_line_circle(vec2 a, vec2 b){
    vec2 a1 = comp_inv(conj(a));
    vec2 b1 = comp_inv(conj(b));
    
    vec2 p1 = 0.5*(a+a1);
    vec2 p2 = 0.5*(b+b1);
    
    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));
    float r = length(a - c);
    return vec3(c,r);
}

vec2 circle_inversion(vec2 p, vec3 circle){
    return circle.z*circle.z*comp_inv(conj(p-circle.xy)) + circle.xy;
}

vec2 beltrami_to_poincare(vec2 p){
    float z = sqrt(1.0 - dot(p,p));
    float alpha = 1.0/(z+1.0);
    return alpha * p;
}

vec2 upper_half_plane_to_poincare(vec2 p){
    p += vec2(0.0,1.0);
    return comp_div(p - vec2(0.0,1.0), p + vec2(0.0,1.0));
}

vec4 tex( vec2 tex_coords )
{
    
    float shade = 1.0 - length(tex_coords);
    return vec4(0.5*shade, shade, 0.5*shade, 1.0);
}

vec4 shader(vec2 uv){

    float p = float(P);
    float q = float(Q);

    if(1.0/p + 1.0/q >= 0.5){
        return vec4(0.0, 0.0, 1.0, 1.0);
    }
    
    vec2 coords = 2.0*uv-vec2(1.0);
    coords.x *= iResolution.x / iResolution.y;

#ifndef UPPER_HALF_PLANE
    if(length(coords) >= 1.0){
        return vec4(0.3, 0.0, 0.2, 1.0);
    }
#endif

    vec2 mouse = iMouse.xy / iResolution.xy;
    mouse = 2.0*mouse - vec2(1.0);
    mouse.x *= iResolution.x / iResolution.y;
    
    // the beauty of a fragment shader: to apply any transformation whatsoever to the output image, we can
    // simply apply the inverse transformation to the coordinates at the beginning without changing anything else
    
#ifdef BELTRAMI
    coords = beltrami_to_poincare(coords);
    mouse = beltrami_to_poincare(mouse);
#endif

#ifdef UPPER_HALF_PLANE
    coords = upper_half_plane_to_poincare(coords);
    mouse = upper_half_plane_to_poincare(mouse);
#endif

    if(length(mouse) < 1.0){
        coords = map_to_origin(mouse,coords);
    }
    
    // The following is the core procedure (rest is almost all bells and whistles). It's really quite simple.
    // --------------------------------------------------------------------------------------------------
    
    // compute the radius of the polygon (length of line from origin to any vertex)
    // using the hyperbolic law of cosines
    float r = tanh(0.5*acosh((cos(PI/float(Q)) + cos(PI/float(Q))*cos(2.0*PI/float(P)))/(sin(PI/float(Q))*sin(2.0*PI/float(P)))));
    
    // compute the vertices of the polygon in the middle and the circles corresponding to its sides
    vec2 vertices[P];
    vec3 circles[P];
    for(int i = 0; i < P; i++){
        vertices[i] = r*vec2(cos(float(i)*2.0*PI/p),sin(float(i)*2.0*PI/p));
    }
    
    for(int i = 0; i < P; i++){
        circles[i] = hyp_line_circle(vertices[i], vertices[(i+1) % P]);
    }

    // test for each side of the polygon whether the current coordinate is in the correct half-space
    // if not, reflect across that side (aka invert in the circle corresponding to it)

    bool inside;
    int iter = 0;

    while(true){
        
        inside = true;

        for(int i = 0; i < P; i++){
        
            if(length(coords - circles[i].xy) < circles[i].z){
                inside = false;
                coords = circle_inversion(coords, circles[i]);
                iter++;
            }
        }
        
        if(inside || iter > MAX_ITER){
            break;
        }
    }
    // ---------------------------------------------------------------------------------------------------
    
    if(COLOR_SCHEME == 0){
        
        for(int i = 0; i < P; i++){
            if(abs(length(coords-circles[i].xy) - circles[i].z) < EDGE_THICKNESS){
                return vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    
        return vec4(1.0);
    }
    
    vec4 color;

    vec2 tex_coords = coords / r;
    
    if(COLOR_SCHEME == 1){
        color = tex(tex_coords);
    }
    
    if(COLOR_SCHEME == 2){
        color = texture(iChannel0, tex_coords);
    }

#ifdef EDGE_OVERLAY
    for(int i = 0; i < int(P); i++){
        if(abs(length(coords-circles[i].xy) - circles[i].z) < EDGE_THICKNESS){
            color = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }
#endif    

    return color;
}

void main( )
{
    vec2 uv = xlv_TEXCOORD0.xy/iResolution.xy;
    vec2 pixel_size = vec2(1.0/iResolution.x,1.0/iResolution.y);
    uv -= pixel_size / 2.0;
    vec2 pixel_inc = pixel_size / float(SAMPLES+1);
    vec4 color = vec4(0.0);
    for(int i = 1; i <= SAMPLES; i++){
        for(int j = 1; j <= SAMPLES; j++){
            color += shader(uv + float(i)*pixel_inc.x + float(j)*pixel_inc.y);
        }
    }
    
    gl_FragColor = color/float(SAMPLES * SAMPLES);
    
}
