/*
  Copyright (c) 2018 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/
#include <c3dbool/BooleanModeller.h>

MeshRenderer2 shape3D;
TextureID texID=-1;

int init(const char* aTitle)
{
	texID=IRenderer::GetRendererInstance()->addImageLibTexture("/test.bmp", false, IRenderer::GetRendererInstance()->Getlinear());
LOG_FNLN;
	MeshRenderer2 shape3D1;
	MeshRenderer2 shape3D2;
LOG_FNLN;
	shape3D.CreateTexturedBox(1.0f, 1.0f, 1.0f, eSimpleShader);
	shape3D1.CreateTexturedBox(1.0f, 1.0f, 1.0f, eShaderNone);
	shape3D2.CreateTexturedBox(1.0f, 1.0f, 1.0f, eShaderNone);
LOG_FNLN;
	D3DXFROMWINEMATRIX m1, m2;
	D3DXFROMWINEMatrixTranslation(&m1, -0.5f, 0.0f, 0.0f);
	D3DXFROMWINEMatrixTranslation(&m2, +0.5f, 0.0f, 0.0f);
LOG_FNLN;
#if 1
	std::vector<MeshRenderer2> av;
	std::vector<D3DXFROMWINEMATRIX> aW;
	av.push_back(shape3D1);
	av.push_back(shape3D2);
	aW.push_back(m1);
	aW.push_back(m2);
	shape3D.CreateCombinedShape(av, aW);
#else
	Solid solid1(shape3D1);
LOG_FNLN;
	Solid solid2(shape3D2);
LOG_FNLN;
	BooleanModeller bm(solid1, solid2);
LOG_FNLN;
	//-------------------------------BOOLEAN_OPERATIONS-----------------------------//
	#if 1
	/**
	 * Gets the solid generated by the union of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the union of the two solids submitted to the constructor
	 */
	Solid s=bm.getUnion();
	#elif 0
	/**
	 * Gets the solid generated by the intersection of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the intersection of the two solids submitted to the constructor.
	 * The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
	 * graph. To check this, use the Solid.isEmpty() method.
	 */
	Solid s=bm.getIntersection();
	#elif 0
	/** Gets the solid generated by the difference of the two solids submitted to the constructor. 
	 * The fist solid is substracted by the second. 
	 * 
	 * @return solid generated by the difference of the two solids submitted to the constructor
	 */
	Solid s=bm.getDifference();
	#endif
LOG_FNLN;
	shape3D=s.GetMesh();
LOG_FNLN;
	#endif
	shape3D.toString();
	return 0;
}

void render()
{
	float f=128.0f/256.0f;
	IRenderer::GetRendererInstance()->Clear(true, true, D3DXFROMWINEVECTOR4 (f, f, f, 1.0f));
	IRenderer::GetRendererInstance()->BeginScene();

	float mAngleX=0.0f;
	float mAngleY=0.0f;
	stx_GetAngles(mAngleX, mAngleY);

	D3DXFROMWINEMATRIX R;
	D3DXFROMWINEMatrixRotationYawPitchRoll( 	&R,
			                            D3DXFROMWINEToRadian(mAngleX),
			                            D3DXFROMWINEToRadian(mAngleY),
			                            0.0f );
	
	#if 0
	shape3D.render(R);
	#else
	shape3D.BeginDraw(R, texID);
	shape3D.EndDraw();
	#endif

	const char* txt = "CTRL-r resets the scene.";
	IRenderer::GetRendererInstance()->drawText(txt, 10, 10, 
		15, 18,
		IRenderer::GetRendererInstance()->GetdefaultFont(), 
		IRenderer::GetRendererInstance()->GetlinearClamp(), 
		IRenderer::GetRendererInstance()->GetblendSrcAlpha(), 
		IRenderer::GetRendererInstance()->GetnoDepthTest());

	IRenderer::GetRendererInstance()->EndScene();
	IRenderer::GetRendererInstance()->Present( );
}

int ApplicationLogic()
{
	IRenderer* r=IRenderer::GetRendererInstance("c3dbool");
	IInput*    i=STX_Service::GetInputInstance();
	init("");
	while (!i->OnKeyPress (STX_KEY_ESCAPE) && !i->Quit())
	{
		i->Update();
		render();
	}
	return 0;
}

