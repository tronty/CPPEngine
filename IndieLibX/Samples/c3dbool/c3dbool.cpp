/*
  Copyright (c) 2018 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/
#include <c3dbool/BooleanModeller.h>

class c3dbool : public STXGUI {
public:
	MeshRenderer2 shape3D;
	TextureID texID;
	unsigned int m_i;
	c3dbool()
	{
		m_i=0;
		texID=-1;
	}
	virtual ~c3dbool(){}
void Do(unsigned int i=0)
{
//LOG_FNLN;
	MeshRenderer2 shape3D1;
	MeshRenderer2 shape3D2;
//LOG_FNLN;
	shape3D.CreateTexturedBox(1.0f, 1.0f, 1.0f, eSimpleShader);
	shape3D1.CreateTexturedBox(1.0f, 1.0f, 1.0f, eShaderNone);
	shape3D2.CreateTexturedBox(1.0f, 1.0f, 1.0f, eShaderNone);
//LOG_FNLN;
	D3DXFROMWINEMATRIX m1, m2;
	D3DXFROMWINEMatrixTranslation(&m1, -0.5f, 0.0f, 0.0f);
	D3DXFROMWINEMatrixTranslation(&m2, +0.5f, 0.0f, 0.0f);
//LOG_FNLN;
#if 1
	std::vector<MeshRenderer2> av;
	std::vector<D3DXFROMWINEMATRIX> aW;
	av.push_back(shape3D1);
	av.push_back(shape3D2);
	aW.push_back(m1);
	aW.push_back(m2);
	shape3D.CreateCombinedShape(av, aW);
#endif
//LOG_FNLN;
	Solid solid1(shape3D1);
//LOG_FNLN;
	Solid solid2(shape3D2);
//LOG_FNLN;
	BooleanModeller bm(solid1, solid2);
//LOG_FNLN;
	//-------------------------------BOOLEAN_OPERATIONS-----------------------------//
	#if 0
	/**
	 * Gets the solid generated by the union of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the union of the two solids submitted to the constructor
	 */
	Solid s=bm.getUnion();
	#elif 0
	/**
	 * Gets the solid generated by the intersection of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the intersection of the two solids submitted to the constructor.
	 * The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
	 * graph. To check this, use the Solid.isEmpty() method.
	 */
	Solid s=bm.getIntersection();
	#elif 0
	/** Gets the solid generated by the difference of the two solids submitted to the constructor. 
	 * The fist solid is substracted by the second. 
	 * 
	 * @return solid generated by the difference of the two solids submitted to the constructor
	 */
	Solid s=bm.getDifference();
	#endif

//LOG_FNLN;
	Solid s;


//LOG_FNLN;
	switch(m_i)
	{
		case 0:
			shape3D.CreateCombinedShape(av, aW);
			break;
		case 1:
			s=bm.getUnion();
			s.GetMesh(shape3D);
			break;
		case 2:
			s=bm.getIntersection();
			s.GetMesh(shape3D);
			break;
		case 3:
			s=bm.getDifference();
			s.GetMesh(shape3D);
			break;
		default:
			shape3D.CreateCombinedShape(av, aW);
			break;
	};

//LOG_FNLN;
	shape3D.toString();

//LOG_FNLN;
}

	virtual void actionPerformed(GUIEvent &evt)
{
  const NSString &callbackString  = evt.getCallbackString();
  GUIRectangle *sourceRectangle = evt.getEventSource();
  int widgetType      = sourceRectangle->getWidgetType();

  if(widgetType == RADIO_BUTTON)
  {
	GUIRadioButton   *radioButton = (GUIRadioButton*)sourceRectangle;
	if(radioButton->isPressed() && radioButton->isChecked())
	{
		//LOG_PRINT("callbackString=%s\n", callbackString.data);
		if(callbackString == "CombinedShapeFW3") 
		{
			m_i=0;
			Do(m_i);
		}
		else if(callbackString == "Union") 
		{
			m_i=1;
			Do(m_i);
		}
		else if(callbackString == "Intersection") 
		{
			m_i=2;
			Do(m_i);
		}
		else if(callbackString == "Difference") 
		{
			m_i=3;
			Do(m_i);
		}
}}}

int init(const char* aTitle)
{

//LOG_FNLN;
	texID=IRenderer::GetRendererInstance()->addImageLibTexture("/test.bmp", false, IRenderer::GetRendererInstance()->Getlinear());

//LOG_FNLN;
	STXGUI::init("/c3dbool/GUILayout.xml");

//LOG_FNLN;
	Do(m_i);		

//LOG_FNLN;
	//stx_exit(0);
	return 0;
}

void render()
{
	float f=128.0f/256.0f;
	IRenderer::GetRendererInstance()->Clear(true, true, D3DXFROMWINEVECTOR4 (f, f, f, 1.0f));
	IRenderer::GetRendererInstance()->BeginScene();

	float mAngleX=0.0f;
	float mAngleY=0.0f;
	stx_GetAngles(mAngleX, mAngleY);

	D3DXFROMWINEMATRIX R;
	D3DXFROMWINEMatrixRotationYawPitchRoll( 	&R,
			                            D3DXFROMWINEToRadian(mAngleX),
			                            D3DXFROMWINEToRadian(mAngleY),
			                            0.0f );
	
	#if 0
	shape3D.render(&R);
	#else
	shape3D.BeginDraw(&R, texID);
	shape3D.EndDraw();
	#endif

	const char* txt = "CTRL-r resets the scene.";
	IRenderer::GetRendererInstance()->drawText(txt, 10, 10, 
		15, 18,
		IRenderer::GetRendererInstance()->GetdefaultFont(), 
		IRenderer::GetRendererInstance()->GetlinearClamp(), 
		IRenderer::GetRendererInstance()->GetblendSrcAlpha(), 
		IRenderer::GetRendererInstance()->GetnoDepthTest());

  		STXGUI::update();

	IRenderer::GetRendererInstance()->EndScene();
	IRenderer::GetRendererInstance()->Present( );
}};

c3dbool app;

int init(const char* aTitle)
{
	app.init(aTitle);
	return 0;
}

void render()
{
	app.render();
}

int ApplicationLogic()
{
	IRenderer* r=IRenderer::GetRendererInstance("c3dbool");
	IInput*    i=STX_Service::GetInputInstance();
	init("");
	while (!i->OnKeyPress (STX_KEY_ESCAPE) && !i->Quit())
	{
		i->Update();
		render();
	}
	return 0;
}

