spine-c/include/spine/SkeletonData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/SkeletonData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/SkeletonData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/IkConstraintData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/IkConstraintData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/IkConstraintData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Skeleton.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Skeleton.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Skeleton.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Skeleton.h:/* Returns -1 if the bone was not found. */
spine-c/include/spine/Skeleton.h:/* Returns -1 if the slot was not found. */
spine-c/include/spine/Skin.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Skin.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Skin.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/AtlasAttachmentLoader.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/AtlasAttachmentLoader.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/AtlasAttachmentLoader.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/EventData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/EventData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/EventData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/SkeletonJson.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/SkeletonJson.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/SkeletonJson.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Bone.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Bone.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Bone.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/AttachmentLoader.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/AttachmentLoader.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/AttachmentLoader.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/AnimationState.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/AnimationState.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/AnimationState.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Attachment.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Attachment.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Attachment.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/SlotData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/SlotData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/SlotData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Slot.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Slot.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Slot.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/MeshAttachment.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/MeshAttachment.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/MeshAttachment.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Animation.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Animation.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Animation.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/extension.h: - An OOP style is used where each "class" is made up of a struct and a number of functions prefixed with the struct name.
spine-c/include/spine/extension.h: - struct fields that are const are readonly. Either they are set in a create function and can never be changed, or they can only
spine-c/include/spine/extension.h: - Inheritance is done using a struct field named "super" as the first field, allowing the struct to be cast to its "super class".
spine-c/include/spine/extension.h: - Classes intended for inheritance provide init/deinit functions which subclasses must call in their create/dispose functions.
spine-c/include/spine/extension.h: - Polymorphism is done by a base class providing function pointers in its init function. The public API delegates to this
spine-c/include/spine/extension.h: - Subclasses do not provide a dispose function, instead the base class' dispose function should be used, which will delegate to
spine-c/include/spine/extension.h: - Classes not designed for inheritance cannot be extended because they may use an internal subclass to hide private data and don't
spine-c/include/spine/extension.h: - The public API hides implementation details, such as init/deinit functions. An internal API is exposed by extension.h to allow
spine-c/include/spine/extension.h: - OOP in C tends to lose type safety. Macros for casting are provided in extension.h to give context for why a cast is being done.
spine-c/include/spine/extension.h: - If SPINE_SHORT_NAMES is defined, the "sp" prefix for all class names is optional.
spine-c/include/spine/extension.h:#define SUPER(VALUE) (&VALUE->super)
spine-c/include/spine/extension.h:#define VTABLE(TYPE,VALUE) ((_##TYPE##Vtable*)((TYPE*)VALUE)->vtable)
spine-c/include/spine/BoneData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/BoneData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/BoneData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/SkeletonBounds.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/SkeletonBounds.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/SkeletonBounds.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/AnimationStateData.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/AnimationStateData.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/AnimationStateData.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/SkinnedMeshAttachment.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/SkinnedMeshAttachment.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/SkinnedMeshAttachment.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/IkConstraint.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/IkConstraint.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/IkConstraint.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Atlas.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Atlas.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Atlas.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/spine.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/spine.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/spine.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/BoundingBoxAttachment.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/BoundingBoxAttachment.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/BoundingBoxAttachment.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/Event.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/Event.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/Event.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/include/spine/RegionAttachment.h: * Copyright (c) 2013-2015, Esoteric Software
spine-c/include/spine/RegionAttachment.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/include/spine/RegionAttachment.h: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SlotData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/SlotData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/SlotData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SlotData.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/SlotData.c:	CONST_CAST(spBoneData*, self->boneData) = boneData;
spine-c/src/spine/SlotData.c:	self->r = 1;
spine-c/src/spine/SlotData.c:	self->g = 1;
spine-c/src/spine/SlotData.c:	self->b = 1;
spine-c/src/spine/SlotData.c:	self->a = 1;
spine-c/src/spine/SlotData.c:	FREE(self->name);
spine-c/src/spine/SlotData.c:	FREE(self->attachmentName);
spine-c/src/spine/SlotData.c:	FREE(self->attachmentName);
spine-c/src/spine/SlotData.c:		MALLOC_STR(self->attachmentName, attachmentName);
spine-c/src/spine/SlotData.c:		CONST_CAST(char*, self->attachmentName) = 0;
spine-c/src/spine/EventData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/EventData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/EventData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/EventData.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/EventData.c:	FREE(self->stringValue);
spine-c/src/spine/EventData.c:	FREE(self->name);
spine-c/src/spine/SkeletonData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/SkeletonData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/SkeletonData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/SkeletonData.c:		spBoneData_dispose(self->bones[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->bones);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/SkeletonData.c:		spSlotData_dispose(self->slots[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->slots);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->skinsCount; ++i)
spine-c/src/spine/SkeletonData.c:		spSkin_dispose(self->skins[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->skins);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->eventsCount; ++i)
spine-c/src/spine/SkeletonData.c:		spEventData_dispose(self->events[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->events);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->animationsCount; ++i)
spine-c/src/spine/SkeletonData.c:		spAnimation_dispose(self->animations[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->animations);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->ikConstraintsCount; ++i)
spine-c/src/spine/SkeletonData.c:		spIkConstraintData_dispose(self->ikConstraints[i]);
spine-c/src/spine/SkeletonData.c:	FREE(self->ikConstraints);
spine-c/src/spine/SkeletonData.c:	FREE(self->hash);
spine-c/src/spine/SkeletonData.c:	FREE(self->version);
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->bones[i]->name, boneName) == 0) return self->bones[i];
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->bones[i]->name, boneName) == 0) return i;
spine-c/src/spine/SkeletonData.c:	return -1;
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->slots[i]->name, slotName) == 0) return self->slots[i];
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->slots[i]->name, slotName) == 0) return i;
spine-c/src/spine/SkeletonData.c:	return -1;
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->skinsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->skins[i]->name, skinName) == 0) return self->skins[i];
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->eventsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->events[i]->name, eventName) == 0) return self->events[i];
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->animationsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->animations[i]->name, animationName) == 0) return self->animations[i];
spine-c/src/spine/SkeletonData.c:	for (i = 0; i < self->ikConstraintsCount; ++i)
spine-c/src/spine/SkeletonData.c:		if (strcmp(self->ikConstraints[i]->name, ikConstraintName) == 0) return self->ikConstraints[i];
spine-c/src/spine/extension.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/extension.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/extension.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/RegionAttachment.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/RegionAttachment.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/RegionAttachment.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/RegionAttachment.c:	FREE(self->path);
spine-c/src/spine/RegionAttachment.c:	self->scaleX = 1;
spine-c/src/spine/RegionAttachment.c:	self->scaleY = 1;
spine-c/src/spine/RegionAttachment.c:	self->r = 1;
spine-c/src/spine/RegionAttachment.c:	self->g = 1;
spine-c/src/spine/RegionAttachment.c:	self->b = 1;
spine-c/src/spine/RegionAttachment.c:	self->a = 1;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X2] = u;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y2] = v2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X3] = u;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y3] = v;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X4] = u2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y4] = v;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X1] = u2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y1] = v2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X1] = u;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y1] = v2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X2] = u;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y2] = v;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X3] = u2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y3] = v;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_X4] = u2;
spine-c/src/spine/RegionAttachment.c:		self->uvs[SP_VERTEX_Y4] = v2;
spine-c/src/spine/RegionAttachment.c:	float regionScaleX = self->width / self->regionOriginalWidth * self->scaleX;
spine-c/src/spine/RegionAttachment.c:	float regionScaleY = self->height / self->regionOriginalHeight * self->scaleY;
spine-c/src/spine/RegionAttachment.c:	float localX = -self->width / 2 * self->scaleX + self->regionOffsetX * regionScaleX;
spine-c/src/spine/RegionAttachment.c:	float localY = -self->height / 2 * self->scaleY + self->regionOffsetY * regionScaleY;
spine-c/src/spine/RegionAttachment.c:	float localX2 = localX + self->regionWidth * regionScaleX;
spine-c/src/spine/RegionAttachment.c:	float localY2 = localY + self->regionHeight * regionScaleY;
spine-c/src/spine/RegionAttachment.c:	float radians = self->rotation * DEG_RAD;
spine-c/src/spine/RegionAttachment.c:	float localXCos = localX * cosine + self->x;
spine-c/src/spine/RegionAttachment.c:	float localYCos = localY * cosine + self->y;
spine-c/src/spine/RegionAttachment.c:	float localX2Cos = localX2 * cosine + self->x;
spine-c/src/spine/RegionAttachment.c:	float localY2Cos = localY2 * cosine + self->y;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_X1] = localXCos - localYSin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_Y1] = localYCos + localXSin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_X2] = localXCos - localY2Sin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_Y2] = localY2Cos + localXSin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_X3] = localX2Cos - localY2Sin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_Y3] = localY2Cos + localX2Sin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_X4] = localX2Cos - localYSin;
spine-c/src/spine/RegionAttachment.c:	self->offset[SP_VERTEX_Y4] = localYCos + localX2Sin;
spine-c/src/spine/RegionAttachment.c:	const float* offset = self->offset;
spine-c/src/spine/RegionAttachment.c:	float x = bone->skeleton->x + bone->worldX, y = bone->skeleton->y + bone->worldY;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_X1] = offset[SP_VERTEX_X1] * bone->m00 + offset[SP_VERTEX_Y1] * bone->m01 + x;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_Y1] = offset[SP_VERTEX_X1] * bone->m10 + offset[SP_VERTEX_Y1] * bone->m11 + y;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_X2] = offset[SP_VERTEX_X2] * bone->m00 + offset[SP_VERTEX_Y2] * bone->m01 + x;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_Y2] = offset[SP_VERTEX_X2] * bone->m10 + offset[SP_VERTEX_Y2] * bone->m11 + y;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_X3] = offset[SP_VERTEX_X3] * bone->m00 + offset[SP_VERTEX_Y3] * bone->m01 + x;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_Y3] = offset[SP_VERTEX_X3] * bone->m10 + offset[SP_VERTEX_Y3] * bone->m11 + y;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_X4] = offset[SP_VERTEX_X4] * bone->m00 + offset[SP_VERTEX_Y4] * bone->m01 + x;
spine-c/src/spine/RegionAttachment.c:	vertices[SP_VERTEX_Y4] = offset[SP_VERTEX_X4] * bone->m10 + offset[SP_VERTEX_Y4] * bone->m11 + y;
spine-c/src/spine/Skeleton.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Skeleton.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Skeleton.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Skeleton.c:	CONST_CAST(spSkeletonData*, self->data) = data;
spine-c/src/spine/Skeleton.c:	self->bonesCount = self->data->bonesCount;
spine-c/src/spine/Skeleton.c:	self->bones = MALLOC(spBone*, self->bonesCount);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i) {
spine-c/src/spine/Skeleton.c:		spBoneData* boneData = self->data->bones[i];
spine-c/src/spine/Skeleton.c:		if (boneData->parent) {
spine-c/src/spine/Skeleton.c:			for (ii = 0; ii < self->bonesCount; ++ii) {
spine-c/src/spine/Skeleton.c:				if (data->bones[ii] == boneData->parent) {
spine-c/src/spine/Skeleton.c:					parent = self->bones[ii];
spine-c/src/spine/Skeleton.c:		self->bones[i] = spBone_create(boneData, self, parent);
spine-c/src/spine/Skeleton.c:	CONST_CAST(spBone*, self->root) = self->bones[0];
spine-c/src/spine/Skeleton.c:	self->slotsCount = data->slotsCount;
spine-c/src/spine/Skeleton.c:	self->slots = MALLOC(spSlot*, self->slotsCount);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i) {
spine-c/src/spine/Skeleton.c:		spSlotData *slotData = data->slots[i];
spine-c/src/spine/Skeleton.c:		for (ii = 0; ii < self->bonesCount; ++ii) {
spine-c/src/spine/Skeleton.c:			if (data->bones[ii] == slotData->boneData) {
spine-c/src/spine/Skeleton.c:				bone = self->bones[ii];
spine-c/src/spine/Skeleton.c:		self->slots[i] = spSlot_create(slotData, bone);
spine-c/src/spine/Skeleton.c:	self->drawOrder = MALLOC(spSlot*, self->slotsCount);
spine-c/src/spine/Skeleton.c:	memcpy(self->drawOrder, self->slots, sizeof(spSlot*) * self->slotsCount);
spine-c/src/spine/Skeleton.c:	self->r = 1;
spine-c/src/spine/Skeleton.c:	self->g = 1;
spine-c/src/spine/Skeleton.c:	self->b = 1;
spine-c/src/spine/Skeleton.c:	self->a = 1;
spine-c/src/spine/Skeleton.c:	self->ikConstraintsCount = data->ikConstraintsCount;
spine-c/src/spine/Skeleton.c:	self->ikConstraints = MALLOC(spIkConstraint*, self->ikConstraintsCount);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->data->ikConstraintsCount; ++i)
spine-c/src/spine/Skeleton.c:		self->ikConstraints[i] = spIkConstraint_create(self->data->ikConstraints[i], self);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < internal->boneCacheCount; ++i)
spine-c/src/spine/Skeleton.c:		FREE(internal->boneCache[i]);
spine-c/src/spine/Skeleton.c:	FREE(internal->boneCache);
spine-c/src/spine/Skeleton.c:	FREE(internal->boneCacheCounts);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/Skeleton.c:		spBone_dispose(self->bones[i]);
spine-c/src/spine/Skeleton.c:	FREE(self->bones);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/Skeleton.c:		spSlot_dispose(self->slots[i]);
spine-c/src/spine/Skeleton.c:	FREE(self->slots);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->ikConstraintsCount; ++i)
spine-c/src/spine/Skeleton.c:		spIkConstraint_dispose(self->ikConstraints[i]);
spine-c/src/spine/Skeleton.c:	FREE(self->ikConstraints);
spine-c/src/spine/Skeleton.c:	FREE(self->drawOrder);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < internal->boneCacheCount; ++i)
spine-c/src/spine/Skeleton.c:		FREE(internal->boneCache[i]);
spine-c/src/spine/Skeleton.c:	FREE(internal->boneCache);
spine-c/src/spine/Skeleton.c:	FREE(internal->boneCacheCounts);
spine-c/src/spine/Skeleton.c:	internal->boneCacheCount = self->ikConstraintsCount + 1;
spine-c/src/spine/Skeleton.c:	internal->boneCache = MALLOC(spBone**, internal->boneCacheCount);
spine-c/src/spine/Skeleton.c:	internal->boneCacheCounts = CALLOC(int, internal->boneCacheCount);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i) {
spine-c/src/spine/Skeleton.c:		spBone* current = self->bones[i];
spine-c/src/spine/Skeleton.c:			for (ii = 0; ii < self->ikConstraintsCount; ++ii) {
spine-c/src/spine/Skeleton.c:				spIkConstraint* ikConstraint = self->ikConstraints[ii];
spine-c/src/spine/Skeleton.c:				spBone* parent = ikConstraint->bones[0];
spine-c/src/spine/Skeleton.c:				spBone* child = ikConstraint->bones[ikConstraint->bonesCount - 1];
spine-c/src/spine/Skeleton.c:						internal->boneCacheCounts[ii]++;
spine-c/src/spine/Skeleton.c:						internal->boneCacheCounts[ii + 1]++;
spine-c/src/spine/Skeleton.c:					child = child->parent;
spine-c/src/spine/Skeleton.c:			current = current->parent;
spine-c/src/spine/Skeleton.c:		internal->boneCacheCounts[0]++;
spine-c/src/spine/Skeleton.c:	for (i = 0; i < internal->boneCacheCount; ++i)
spine-c/src/spine/Skeleton.c:		internal->boneCache[i] = MALLOC(spBone*, internal->boneCacheCounts[i]);
spine-c/src/spine/Skeleton.c:	memset(internal->boneCacheCounts, 0, internal->boneCacheCount * sizeof(int));
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i) {
spine-c/src/spine/Skeleton.c:		spBone* bone = self->bones[i];
spine-c/src/spine/Skeleton.c:			for (ii = 0; ii < self->ikConstraintsCount; ++ii) {
spine-c/src/spine/Skeleton.c:				spIkConstraint* ikConstraint = self->ikConstraints[ii];
spine-c/src/spine/Skeleton.c:				spBone* parent = ikConstraint->bones[0];
spine-c/src/spine/Skeleton.c:				spBone* child = ikConstraint->bones[ikConstraint->bonesCount - 1];
spine-c/src/spine/Skeleton.c:						internal->boneCache[ii][internal->boneCacheCounts[ii]++] = bone;
spine-c/src/spine/Skeleton.c:						internal->boneCache[ii + 1][internal->boneCacheCounts[ii + 1]++] = bone;
spine-c/src/spine/Skeleton.c:					child = child->parent;
spine-c/src/spine/Skeleton.c:			current = current->parent;
spine-c/src/spine/Skeleton.c:		internal->boneCache[0][internal->boneCacheCounts[0]++] = bone;
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/Skeleton.c:		self->bones[i]->rotationIK = self->bones[i]->rotation;
spine-c/src/spine/Skeleton.c:	last = internal->boneCacheCount - 1;
spine-c/src/spine/Skeleton.c:		for (ii = 0, nn = internal->boneCacheCounts[i]; ii < nn; ++ii)
spine-c/src/spine/Skeleton.c:			spBone_updateWorldTransform(internal->boneCache[i][ii]);
spine-c/src/spine/Skeleton.c:		spIkConstraint_apply(self->ikConstraints[i]);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/Skeleton.c:		spBone_setToSetupPose(self->bones[i]);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->ikConstraintsCount; ++i) {
spine-c/src/spine/Skeleton.c:		spIkConstraint* ikConstraint = self->ikConstraints[i];
spine-c/src/spine/Skeleton.c:		ikConstraint->bendDirection = ikConstraint->data->bendDirection;
spine-c/src/spine/Skeleton.c:		ikConstraint->mix = ikConstraint->data->mix;
spine-c/src/spine/Skeleton.c:	memcpy(self->drawOrder, self->slots, self->slotsCount * sizeof(spSlot*));
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/Skeleton.c:		spSlot_setToSetupPose(self->slots[i]);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/Skeleton.c:		if (strcmp(self->data->bones[i]->name, boneName) == 0) return self->bones[i];
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/Skeleton.c:		if (strcmp(self->data->bones[i]->name, boneName) == 0) return i;
spine-c/src/spine/Skeleton.c:	return -1;
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/Skeleton.c:		if (strcmp(self->data->slots[i]->name, slotName) == 0) return self->slots[i];
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/Skeleton.c:		if (strcmp(self->data->slots[i]->name, slotName) == 0) return i;
spine-c/src/spine/Skeleton.c:	return -1;
spine-c/src/spine/Skeleton.c:	skin = spSkeletonData_findSkin(self->data, skinName);
spine-c/src/spine/Skeleton.c:		if (self->skin)
spine-c/src/spine/Skeleton.c:			spSkin_attachAll(newSkin, self, self->skin);
spine-c/src/spine/Skeleton.c:			for (i = 0; i < self->slotsCount; ++i) {
spine-c/src/spine/Skeleton.c:				spSlot* slot = self->slots[i];
spine-c/src/spine/Skeleton.c:				if (slot->data->attachmentName) {
spine-c/src/spine/Skeleton.c:					spAttachment* attachment = spSkin_getAttachment(newSkin, i, slot->data->attachmentName);
spine-c/src/spine/Skeleton.c:	CONST_CAST(spSkin*, self->skin) = newSkin;
spine-c/src/spine/Skeleton.c:	int slotIndex = spSkeletonData_findSlotIndex(self->data, slotName);
spine-c/src/spine/Skeleton.c:	if (slotIndex == -1) return 0;
spine-c/src/spine/Skeleton.c:	if (self->skin) {
spine-c/src/spine/Skeleton.c:		spAttachment *attachment = spSkin_getAttachment(self->skin, slotIndex, attachmentName);
spine-c/src/spine/Skeleton.c:	if (self->data->defaultSkin) {
spine-c/src/spine/Skeleton.c:		spAttachment *attachment = spSkin_getAttachment(self->data->defaultSkin, slotIndex, attachmentName);
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->slotsCount; ++i) {
spine-c/src/spine/Skeleton.c:		spSlot *slot = self->slots[i];
spine-c/src/spine/Skeleton.c:		if (strcmp(slot->data->name, slotName) == 0) {
spine-c/src/spine/Skeleton.c:	for (i = 0; i < self->ikConstraintsCount; ++i)
spine-c/src/spine/Skeleton.c:		if (strcmp(self->ikConstraints[i]->data->name, ikConstraintName) == 0) return self->ikConstraints[i];
spine-c/src/spine/Skeleton.c:	self->time += deltaTime;
spine-c/src/spine/Json.c:#include <string.h> /* strcasecmp (4.4BSD - compatibility), _stricmp (_WIN32) */
spine-c/src/spine/Json.c:/* Define this to do extra NULL and expected-character checking */
spine-c/src/spine/Json.c:			return -1; /* s1 is null, s2 is not */
spine-c/src/spine/Json.c:		next = c->next;
spine-c/src/spine/Json.c:		if (c->child) Json_dispose(c->child);
spine-c/src/spine/Json.c:		if (c->valueString) FREE(c->valueString);
spine-c/src/spine/Json.c:		if (c->name) FREE(c->name);
spine-c/src/spine/Json.c:	 * accepting for example hex-encoded floating point, but either
spine-c/src/spine/Json.c:	 * We also already know that this starts with [-0-9] from parse_value.
spine-c/src/spine/Json.c:	/* ignore errno's ERANGE, which returns +/-HUGE_VAL */
spine-c/src/spine/Json.c:		item->valueFloat = n;
spine-c/src/spine/Json.c:		item->valueInt = (int)n;
spine-c/src/spine/Json.c:		item->type = Json_Number;
spine-c/src/spine/Json.c:					if (ptr[1] != '\\' || ptr[2] != 'u') break; /* missing second-half of surrogate.	*/
spine-c/src/spine/Json.c:					if (uc2 < 0xDC00 || uc2 > 0xDFFF) break; /* invalid second-half of surrogate.	*/
spine-c/src/spine/Json.c:					*--ptr2 = ((uc | 0x80) & 0xBF);
spine-c/src/spine/Json.c:					*--ptr2 = ((uc | 0x80) & 0xBF);
spine-c/src/spine/Json.c:					*--ptr2 = ((uc | 0x80) & 0xBF);
spine-c/src/spine/Json.c:					*--ptr2 = (uc | firstByteMark[len]);
spine-c/src/spine/Json.c:	item->valueString = out;
spine-c/src/spine/Json.c:	item->type = Json_String;
spine-c/src/spine/Json.c:/* Parse an object - create a new root, and populate. */
spine-c/src/spine/Json.c:/* Parser core - when encountering text, process appropriately. */
spine-c/src/spine/Json.c:			item->type = Json_NULL;
spine-c/src/spine/Json.c:			item->type = Json_False;
spine-c/src/spine/Json.c:			/* calloc prevents us needing item->type = Json_False or valueInt = 0 here */
spine-c/src/spine/Json.c:			item->type = Json_True;
spine-c/src/spine/Json.c:			item->valueInt = 1;
spine-c/src/spine/Json.c:	case '-': /* fallthrough */
spine-c/src/spine/Json.c:	item->type = Json_Array;
spine-c/src/spine/Json.c:	item->child = child = Json_new();
spine-c/src/spine/Json.c:	if (!item->child) return 0; /* memory fail */
spine-c/src/spine/Json.c:	item->size = 1;
spine-c/src/spine/Json.c:		child->next = new_item;
spine-c/src/spine/Json.c:		new_item->prev = child;
spine-c/src/spine/Json.c:		item->size++;
spine-c/src/spine/Json.c:	item->type = Json_Object;
spine-c/src/spine/Json.c:	item->child = child = Json_new();
spine-c/src/spine/Json.c:	if (!item->child) return 0;
spine-c/src/spine/Json.c:	child->name = child->valueString;
spine-c/src/spine/Json.c:	child->valueString = 0;
spine-c/src/spine/Json.c:	item->size = 1;
spine-c/src/spine/Json.c:		child->next = new_item;
spine-c/src/spine/Json.c:		new_item->prev = child;
spine-c/src/spine/Json.c:		child->name = child->valueString;
spine-c/src/spine/Json.c:		child->valueString = 0;
spine-c/src/spine/Json.c:		item->size++;
spine-c/src/spine/Json.c:	Json *c = object->child;
spine-c/src/spine/Json.c:	while (c && Json_strcasecmp(c->name, string))
spine-c/src/spine/Json.c:		c = c->next;
spine-c/src/spine/Json.c:	if (object) return object->valueString;
spine-c/src/spine/Json.c:	return value ? value->valueFloat : defaultValue;
spine-c/src/spine/Json.c:	return value ? value->valueInt : defaultValue;
spine-c/src/spine/BoneData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/BoneData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/BoneData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/BoneData.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/BoneData.c:	CONST_CAST(spBoneData*, self->parent) = parent;
spine-c/src/spine/BoneData.c:	self->scaleX = 1;
spine-c/src/spine/BoneData.c:	self->scaleY = 1;
spine-c/src/spine/BoneData.c:	self->inheritScale = 1;
spine-c/src/spine/BoneData.c:	self->inheritRotation = 1;
spine-c/src/spine/BoneData.c:	FREE(self->name);
spine-c/src/spine/AttachmentLoader.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/AttachmentLoader.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/AttachmentLoader.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/AttachmentLoader.c:	CONST_CAST(_spAttachmentLoaderVtable*, self->vtable) = NEW(_spAttachmentLoaderVtable);
spine-c/src/spine/AttachmentLoader.c:	VTABLE(spAttachmentLoader, self)->dispose = dispose;
spine-c/src/spine/AttachmentLoader.c:	VTABLE(spAttachmentLoader, self)->newAttachment = newAttachment;
spine-c/src/spine/AttachmentLoader.c:	FREE(self->vtable);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error1);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error2);
spine-c/src/spine/AttachmentLoader.c:	VTABLE(spAttachmentLoader, self)->dispose(self);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error1);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error2);
spine-c/src/spine/AttachmentLoader.c:	self->error1 = 0;
spine-c/src/spine/AttachmentLoader.c:	self->error2 = 0;
spine-c/src/spine/AttachmentLoader.c:	return VTABLE(spAttachmentLoader, self)->newAttachment(self, skin, type, name, path);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error1);
spine-c/src/spine/AttachmentLoader.c:	FREE(self->error2);
spine-c/src/spine/AttachmentLoader.c:	MALLOC_STR(self->error1, error1);
spine-c/src/spine/AttachmentLoader.c:	MALLOC_STR(self->error2, error2);
spine-c/src/spine/IkConstraint.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/IkConstraint.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/IkConstraint.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/IkConstraint.c:	CONST_CAST(spIkConstraintData*, self->data) = data;
spine-c/src/spine/IkConstraint.c:	self->bendDirection = data->bendDirection;
spine-c/src/spine/IkConstraint.c:	self->mix = data->mix;
spine-c/src/spine/IkConstraint.c:	self->bonesCount = self->data->bonesCount;
spine-c/src/spine/IkConstraint.c:	self->bones = MALLOC(spBone*, self->bonesCount);
spine-c/src/spine/IkConstraint.c:	for (i = 0; i < self->bonesCount; ++i)
spine-c/src/spine/IkConstraint.c:		self->bones[i] = spSkeleton_findBone(skeleton, self->data->bones[i]->name);
spine-c/src/spine/IkConstraint.c:	self->target = spSkeleton_findBone(skeleton, self->data->target->name);
spine-c/src/spine/IkConstraint.c:	FREE(self->bones);
spine-c/src/spine/IkConstraint.c:	switch (self->bonesCount) {
spine-c/src/spine/IkConstraint.c:		spIkConstraint_apply1(self->bones[0], self->target->worldX, self->target->worldY, self->mix);
spine-c/src/spine/IkConstraint.c:		spIkConstraint_apply2(self->bones[0], self->bones[1], self->target->worldX, self->target->worldY, self->bendDirection,
spine-c/src/spine/IkConstraint.c:				self->mix);
spine-c/src/spine/IkConstraint.c:	float parentRotation = (!bone->data->inheritRotation || !bone->parent) ? 0 : bone->parent->worldRotation;
spine-c/src/spine/IkConstraint.c:	float rotation = bone->rotation;
spine-c/src/spine/IkConstraint.c:	float rotationIK = ATAN2(targetY - bone->worldY, targetX - bone->worldX) * RAD_DEG;
spine-c/src/spine/IkConstraint.c:	if (bone->worldFlipX != (bone->worldFlipY != spBone_isYDown())) rotationIK = -rotationIK;
spine-c/src/spine/IkConstraint.c:	rotationIK -= parentRotation;
spine-c/src/spine/IkConstraint.c:	bone->rotationIK = rotation + (rotationIK - rotation) * alpha;
spine-c/src/spine/IkConstraint.c:	float childRotation = child->rotation, parentRotation = parent->rotation;
spine-c/src/spine/IkConstraint.c:		child->rotationIK = childRotation;
spine-c/src/spine/IkConstraint.c:		parent->rotationIK = parentRotation;
spine-c/src/spine/IkConstraint.c:	parentParent = parent->parent;
spine-c/src/spine/IkConstraint.c:		targetX = (positionX - parent->x) * parentParent->worldScaleX;
spine-c/src/spine/IkConstraint.c:		targetY = (positionY - parent->y) * parentParent->worldScaleY;
spine-c/src/spine/IkConstraint.c:		targetX -= parent->x;
spine-c/src/spine/IkConstraint.c:		targetY -= parent->y;
spine-c/src/spine/IkConstraint.c:	if (child->parent == parent) {
spine-c/src/spine/IkConstraint.c:		positionX = child->x;
spine-c/src/spine/IkConstraint.c:		positionY = child->y;
spine-c/src/spine/IkConstraint.c:		spBone_localToWorld(child->parent, child->x, child->y, &positionX, &positionY);
spine-c/src/spine/IkConstraint.c:	childX = positionX * parent->worldScaleX;
spine-c/src/spine/IkConstraint.c:	childY = positionY * parent->worldScaleY;
spine-c/src/spine/IkConstraint.c:	len2 = child->data->length * child->worldScaleX;
spine-c/src/spine/IkConstraint.c:	/* Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/ */
spine-c/src/spine/IkConstraint.c:		child->rotationIK = childRotation + (ATAN2(targetY, targetX) * RAD_DEG - parentRotation - childRotation) * alpha;
spine-c/src/spine/IkConstraint.c:	cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
spine-c/src/spine/IkConstraint.c:	if (cos < -1)
spine-c/src/spine/IkConstraint.c:		cos = -1;
spine-c/src/spine/IkConstraint.c:	parentAngle = ATAN2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);
spine-c/src/spine/IkConstraint.c:	rotation = (parentAngle - offset) * RAD_DEG - parentRotation;
spine-c/src/spine/IkConstraint.c:		rotation -= 360;
spine-c/src/spine/IkConstraint.c:	else if (rotation < -180) /**/
spine-c/src/spine/IkConstraint.c:	parent->rotationIK = parentRotation + rotation * alpha;
spine-c/src/spine/IkConstraint.c:	rotation = (childAngle + offset) * RAD_DEG - childRotation;
spine-c/src/spine/IkConstraint.c:		rotation -= 360;
spine-c/src/spine/IkConstraint.c:	else if (rotation < -180) /**/
spine-c/src/spine/IkConstraint.c:	child->rotationIK = childRotation + (rotation + parent->worldRotation - child->parent->worldRotation) * alpha;
spine-c/src/spine/Attachment.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Attachment.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Attachment.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Attachment.c:	CONST_CAST(_spAttachmentVtable*, self->vtable) = NEW(_spAttachmentVtable);
spine-c/src/spine/Attachment.c:	VTABLE(spAttachment, self) ->dispose = dispose;
spine-c/src/spine/Attachment.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/Attachment.c:	CONST_CAST(spAttachmentType, self->type) = type;
spine-c/src/spine/Attachment.c:	FREE(self->vtable);
spine-c/src/spine/Attachment.c:	FREE(self->name);
spine-c/src/spine/Attachment.c:	VTABLE(spAttachment, self) ->dispose(self);
spine-c/src/spine/Skin.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Skin.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Skin.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Skin.c:	self->slotIndex = slotIndex;
spine-c/src/spine/Skin.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/Skin.c:	self->attachment = attachment;
spine-c/src/spine/Skin.c:	spAttachment_dispose(self->attachment);
spine-c/src/spine/Skin.c:	FREE(self->name);
spine-c/src/spine/Skin.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/Skin.c:	_Entry* entry = SUB_CAST(_spSkin, self)->entries;
spine-c/src/spine/Skin.c:		_Entry* nextEntry = entry->next;
spine-c/src/spine/Skin.c:	FREE(self->name);
spine-c/src/spine/Skin.c:	newEntry->next = SUB_CAST(_spSkin, self)->entries;
spine-c/src/spine/Skin.c:	SUB_CAST(_spSkin, self)->entries = newEntry;
spine-c/src/spine/Skin.c:	const _Entry* entry = SUB_CAST(_spSkin, self)->entries;
spine-c/src/spine/Skin.c:		if (entry->slotIndex == slotIndex && strcmp(entry->name, name) == 0) return entry->attachment;
spine-c/src/spine/Skin.c:		entry = entry->next;
spine-c/src/spine/Skin.c:	const _Entry* entry = SUB_CAST(_spSkin, self)->entries;
spine-c/src/spine/Skin.c:		if (entry->slotIndex == slotIndex) {
spine-c/src/spine/Skin.c:			if (i == attachmentIndex) return entry->name;
spine-c/src/spine/Skin.c:		entry = entry->next;
spine-c/src/spine/Skin.c:	const _Entry *entry = SUB_CAST(_spSkin, oldSkin)->entries;
spine-c/src/spine/Skin.c:		spSlot *slot = skeleton->slots[entry->slotIndex];
spine-c/src/spine/Skin.c:		if (slot->attachment == entry->attachment) {
spine-c/src/spine/Skin.c:			spAttachment *attachment = spSkin_getAttachment(self, entry->slotIndex, entry->name);
spine-c/src/spine/Skin.c:		entry = entry->next;
spine-c/src/spine/BoundingBoxAttachment.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/BoundingBoxAttachment.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/BoundingBoxAttachment.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/BoundingBoxAttachment.c:	FREE(self->vertices);
spine-c/src/spine/BoundingBoxAttachment.c:	float* vertices = self->vertices;
spine-c/src/spine/BoundingBoxAttachment.c:	float x = bone->skeleton->x + bone->worldX, y = bone->skeleton->y + bone->worldY;
spine-c/src/spine/BoundingBoxAttachment.c:	for (i = 0; i < self->verticesCount; i += 2) {
spine-c/src/spine/BoundingBoxAttachment.c:		worldVertices[i] = px * bone->m00 + py * bone->m01 + x;
spine-c/src/spine/BoundingBoxAttachment.c:		worldVertices[i + 1] = px * bone->m10 + py * bone->m11 + y;
spine-c/src/spine/extension2.cpp:#include <spine/spine-sfml.h>
spine-c/src/spine/extension2.cpp:	TextureID id=-1;
spine-c/src/spine/extension2.cpp:	id=IRenderer::GetRendererInstance()->addImageLibTexture(
spine-c/src/spine/extension2.cpp:		//IRenderer::GetRendererInstance()->GetbilinearClamp());
spine-c/src/spine/extension2.cpp:		IRenderer::GetRendererInstance()->Getlinear());
spine-c/src/spine/extension2.cpp:	id=IRenderer::GetRendererInstance()->addTexture(&img);
spine-c/src/spine/extension2.cpp:	self->width=IRenderer::GetRendererInstance()->GetTextureWidth (id);
spine-c/src/spine/extension2.cpp:	self->height=IRenderer::GetRendererInstance()->GetTextureHeight(id);
spine-c/src/spine/extension2.cpp:	//printf("self->width =%d\n", self->width);
spine-c/src/spine/extension2.cpp:	//printf("self->height=%d\n", self->height);
spine-c/src/spine/extension2.cpp:	tex->id=id;
spine-c/src/spine/extension2.cpp:	tex->width=self->width;
spine-c/src/spine/extension2.cpp:	tex->height=self->height;
spine-c/src/spine/extension2.cpp:	self->rendererObject=tex;
spine-c/src/spine/AtlasAttachmentLoader.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/AtlasAttachmentLoader.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/AtlasAttachmentLoader.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/AtlasAttachmentLoader.c:		spAtlasRegion* region = spAtlas_findRegion(self->atlas, path);
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->rendererObject = region;
spine-c/src/spine/AtlasAttachmentLoader.c:		spRegionAttachment_setUVs(attachment, region->u, region->v, region->u2, region->v2, region->rotate);
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetX = region->offsetX;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetY = region->offsetY;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionWidth = region->width;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionHeight = region->height;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalWidth = region->originalWidth;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalHeight = region->originalHeight;
spine-c/src/spine/AtlasAttachmentLoader.c:		spAtlasRegion* region = spAtlas_findRegion(self->atlas, path);
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->rendererObject = region;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionU = region->u;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionV = region->v;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionU2 = region->u2;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionV2 = region->v2;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionRotate = region->rotate;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetX = region->offsetX;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetY = region->offsetY;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionWidth = region->width;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionHeight = region->height;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalWidth = region->originalWidth;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalHeight = region->originalHeight;
spine-c/src/spine/AtlasAttachmentLoader.c:		spAtlasRegion* region = spAtlas_findRegion(self->atlas, path);
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->rendererObject = region;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionU = region->u;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionV = region->v;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionU2 = region->u2;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionV2 = region->v2;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionRotate = region->rotate;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetX = region->offsetX;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOffsetY = region->offsetY;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionWidth = region->width;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionHeight = region->height;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalWidth = region->originalWidth;
spine-c/src/spine/AtlasAttachmentLoader.c:		attachment->regionOriginalHeight = region->originalHeight;
spine-c/src/spine/AtlasAttachmentLoader.c:	self->atlas = atlas;
spine-c/src/spine/MeshAttachment.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/MeshAttachment.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/MeshAttachment.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/MeshAttachment.c:	FREE(self->path);
spine-c/src/spine/MeshAttachment.c:	FREE(self->vertices);
spine-c/src/spine/MeshAttachment.c:	FREE(self->regionUVs);
spine-c/src/spine/MeshAttachment.c:	FREE(self->uvs);
spine-c/src/spine/MeshAttachment.c:	FREE(self->triangles);
spine-c/src/spine/MeshAttachment.c:	FREE(self->edges);
spine-c/src/spine/MeshAttachment.c:	self->r = 1;
spine-c/src/spine/MeshAttachment.c:	self->g = 1;
spine-c/src/spine/MeshAttachment.c:	self->b = 1;
spine-c/src/spine/MeshAttachment.c:	self->a = 1;
spine-c/src/spine/MeshAttachment.c:	float width = self->regionU2 - self->regionU, height = self->regionV2 - self->regionV;
spine-c/src/spine/MeshAttachment.c:	FREE(self->uvs);
spine-c/src/spine/MeshAttachment.c:	self->uvs = MALLOC(float, self->verticesCount);
spine-c/src/spine/MeshAttachment.c:	if (self->regionRotate) {
spine-c/src/spine/MeshAttachment.c:		for (i = 0; i < self->verticesCount; i += 2) {
spine-c/src/spine/MeshAttachment.c:			self->uvs[i] = self->regionU + self->regionUVs[i + 1] * width;
spine-c/src/spine/MeshAttachment.c:			self->uvs[i + 1] = self->regionV + height - self->regionUVs[i] * height;
spine-c/src/spine/MeshAttachment.c:		for (i = 0; i < self->verticesCount; i += 2) {
spine-c/src/spine/MeshAttachment.c:			self->uvs[i] = self->regionU + self->regionUVs[i] * width;
spine-c/src/spine/MeshAttachment.c:			self->uvs[i + 1] = self->regionV + self->regionUVs[i + 1] * height;
spine-c/src/spine/MeshAttachment.c:	float* vertices = self->vertices;
spine-c/src/spine/MeshAttachment.c:	const spBone* bone = slot->bone;
spine-c/src/spine/MeshAttachment.c:	float x = bone->skeleton->x + bone->worldX, y = bone->skeleton->y + bone->worldY;
spine-c/src/spine/MeshAttachment.c:	if (slot->attachmentVerticesCount == self->verticesCount) vertices = slot->attachmentVertices;
spine-c/src/spine/MeshAttachment.c:	for (i = 0; i < self->verticesCount; i += 2) {
spine-c/src/spine/MeshAttachment.c:		worldVertices[i] = vx * bone->m00 + vy * bone->m01 + x;
spine-c/src/spine/MeshAttachment.c:		worldVertices[i + 1] = vx * bone->m10 + vy * bone->m11 + y;
spine-c/src/spine/IkConstraintData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/IkConstraintData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/IkConstraintData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/IkConstraintData.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/IkConstraintData.c:	self->bendDirection = 1;
spine-c/src/spine/IkConstraintData.c:	self->mix = 1;
spine-c/src/spine/IkConstraintData.c:	FREE(self->name);
spine-c/src/spine/IkConstraintData.c:	FREE(self->bones);
spine-c/src/spine/Bone.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Bone.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Bone.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Bone.c:	CONST_CAST(spBoneData*, self->data) = data;
spine-c/src/spine/Bone.c:	CONST_CAST(spSkeleton*, self->skeleton) = skeleton;
spine-c/src/spine/Bone.c:	CONST_CAST(spBone*, self->parent) = parent;
spine-c/src/spine/Bone.c:	if (self->parent) {
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldX) = self->x * self->parent->m00 + self->y * self->parent->m01 + self->parent->worldX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldY) = self->x * self->parent->m10 + self->y * self->parent->m11 + self->parent->worldY;
spine-c/src/spine/Bone.c:		if (self->data->inheritScale) {
spine-c/src/spine/Bone.c:			CONST_CAST(float, self->worldScaleX) = self->parent->worldScaleX * self->scaleX;
spine-c/src/spine/Bone.c:			CONST_CAST(float, self->worldScaleY) = self->parent->worldScaleY * self->scaleY;
spine-c/src/spine/Bone.c:			CONST_CAST(float, self->worldScaleX) = self->scaleX;
spine-c/src/spine/Bone.c:			CONST_CAST(float, self->worldScaleY) = self->scaleY;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldRotation) =
spine-c/src/spine/Bone.c:				self->data->inheritRotation ? self->parent->worldRotation + self->rotationIK : self->rotationIK;
spine-c/src/spine/Bone.c:		CONST_CAST(int, self->worldFlipX) = self->parent->worldFlipX ^ self->flipX;
spine-c/src/spine/Bone.c:		CONST_CAST(int, self->worldFlipY) = self->parent->worldFlipY ^ self->flipY;
spine-c/src/spine/Bone.c:		int skeletonFlipX = self->skeleton->flipX, skeletonFlipY = self->skeleton->flipY;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldX) = self->skeleton->flipX ? -self->x : self->x;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldY) = self->skeleton->flipY != yDown ? -self->y : self->y;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldScaleX) = self->scaleX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldScaleY) = self->scaleY;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->worldRotation) = self->rotationIK;
spine-c/src/spine/Bone.c:		CONST_CAST(int, self->worldFlipX) = skeletonFlipX ^ self->flipX;
spine-c/src/spine/Bone.c:		CONST_CAST(int, self->worldFlipY) = skeletonFlipY ^ self->flipY;
spine-c/src/spine/Bone.c:	radians = self->worldRotation * DEG_RAD;
spine-c/src/spine/Bone.c:	if (self->worldFlipX) {
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m00) = -cosine * self->worldScaleX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m01) = sine * self->worldScaleY;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m00) = cosine * self->worldScaleX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m01) = -sine * self->worldScaleY;
spine-c/src/spine/Bone.c:	if (self->worldFlipY != yDown) {
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m10) = -sine * self->worldScaleX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m11) = -cosine * self->worldScaleY;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m10) = sine * self->worldScaleX;
spine-c/src/spine/Bone.c:		CONST_CAST(float, self->m11) = cosine * self->worldScaleY;
spine-c/src/spine/Bone.c:	self->x = self->data->x;
spine-c/src/spine/Bone.c:	self->y = self->data->y;
spine-c/src/spine/Bone.c:	self->rotation = self->data->rotation;
spine-c/src/spine/Bone.c:	self->rotationIK = self->rotation;
spine-c/src/spine/Bone.c:	self->scaleX = self->data->scaleX;
spine-c/src/spine/Bone.c:	self->scaleY = self->data->scaleY;
spine-c/src/spine/Bone.c:	self->flipX = self->data->flipX;
spine-c/src/spine/Bone.c:	self->flipY = self->data->flipY;
spine-c/src/spine/Bone.c:	float dx = worldX - self->worldX, dy = worldY - self->worldY;
spine-c/src/spine/Bone.c:	float m00 = self->m00, m11 = self->m11;
spine-c/src/spine/Bone.c:	if (self->worldFlipX != (self->worldFlipY != yDown)) {
spine-c/src/spine/Bone.c:		m00 *= -1;
spine-c/src/spine/Bone.c:		m11 *= -1;
spine-c/src/spine/Bone.c:	invDet = 1 / (m00 * m11 - self->m01 * self->m10);
spine-c/src/spine/Bone.c:	*localX = (dx * m00 * invDet - dy * self->m01 * invDet);
spine-c/src/spine/Bone.c:	*localY = (dy * m11 * invDet - dx * self->m10 * invDet);
spine-c/src/spine/Bone.c:	*worldX = localX * self->m00 + localY * self->m01 + self->worldX;
spine-c/src/spine/Bone.c:	*worldY = localX * self->m10 + localY * self->m11 + self->worldY;
spine-c/src/spine/SkeletonJson.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/SkeletonJson.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/SkeletonJson.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SkeletonJson.c:	self->scale = 1;
spine-c/src/spine/SkeletonJson.c:	self->attachmentLoader = attachmentLoader;
spine-c/src/spine/SkeletonJson.c:	SUB_CAST(_spSkeletonJson, self)->ownsLoader = 1;
spine-c/src/spine/SkeletonJson.c:	if (SUB_CAST(_spSkeletonJson, self)->ownsLoader) spAttachmentLoader_dispose(self->attachmentLoader);
spine-c/src/spine/SkeletonJson.c:	FREE(self->error);
spine-c/src/spine/SkeletonJson.c:	FREE(self->error);
spine-c/src/spine/SkeletonJson.c:	if (value2) strncat(message + length, value2, 255 - length);
spine-c/src/spine/SkeletonJson.c:	MALLOC_STR(self->error, message);
spine-c/src/spine/SkeletonJson.c:	if (strlen(value) != 8) return -1;
spine-c/src/spine/SkeletonJson.c:	if (*error != 0) return -1;
spine-c/src/spine/SkeletonJson.c:	if (curve->type == Json_String && strcmp(curve->valueString, "stepped") == 0)
spine-c/src/spine/SkeletonJson.c:	else if (curve->type == Json_Array) {
spine-c/src/spine/SkeletonJson.c:		Json* child0 = curve->child;
spine-c/src/spine/SkeletonJson.c:		Json* child1 = child0->next;
spine-c/src/spine/SkeletonJson.c:		Json* child2 = child1->next;
spine-c/src/spine/SkeletonJson.c:		Json* child3 = child2->next;
spine-c/src/spine/SkeletonJson.c:		spCurveTimeline_setCurve(timeline, frameIndex, child0->valueFloat, child1->valueFloat, child2->valueFloat,
spine-c/src/spine/SkeletonJson.c:				child3->valueFloat);
spine-c/src/spine/SkeletonJson.c:	for (boneMap = bones ? bones->child : 0; boneMap; boneMap = boneMap->next)
spine-c/src/spine/SkeletonJson.c:		timelinesCount += boneMap->size;
spine-c/src/spine/SkeletonJson.c:	for (slotMap = slots ? slots->child : 0; slotMap; slotMap = slotMap->next)
spine-c/src/spine/SkeletonJson.c:		timelinesCount += slotMap->size;
spine-c/src/spine/SkeletonJson.c:	timelinesCount += ik ? ik->size : 0;
spine-c/src/spine/SkeletonJson.c:	for (ffdMap = ffd ? ffd->child : 0; ffdMap; ffdMap = ffdMap->next)
spine-c/src/spine/SkeletonJson.c:		for (slotMap = ffdMap->child; slotMap; slotMap = slotMap->next)
spine-c/src/spine/SkeletonJson.c:			timelinesCount += slotMap->size;
spine-c/src/spine/SkeletonJson.c:	animation = spAnimation_create(root->name, timelinesCount);
spine-c/src/spine/SkeletonJson.c:	animation->timelinesCount = 0;
spine-c/src/spine/SkeletonJson.c:	skeletonData->animations[skeletonData->animationsCount++] = animation;
spine-c/src/spine/SkeletonJson.c:	for (slotMap = slots ? slots->child : 0; slotMap; slotMap = slotMap->next) {
spine-c/src/spine/SkeletonJson.c:		int slotIndex = spSkeletonData_findSlotIndex(skeletonData, slotMap->name);
spine-c/src/spine/SkeletonJson.c:		if (slotIndex == -1) {
spine-c/src/spine/SkeletonJson.c:			_spSkeletonJson_setError(self, root, "Slot not found: ", slotMap->name);
spine-c/src/spine/SkeletonJson.c:		for (timelineArray = slotMap->child; timelineArray; timelineArray = timelineArray->next) {
spine-c/src/spine/SkeletonJson.c:			if (strcmp(timelineArray->name, "color") == 0) {
spine-c/src/spine/SkeletonJson.c:				spColorTimeline *timeline = spColorTimeline_create(timelineArray->size);
spine-c/src/spine/SkeletonJson.c:				timeline->slotIndex = slotIndex;
spine-c/src/spine/SkeletonJson.c:				for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:				animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:				duration = timeline->frames[timelineArray->size * 5 - 5];
spine-c/src/spine/SkeletonJson.c:				if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:			} else if (strcmp(timelineArray->name, "attachment") == 0) {
spine-c/src/spine/SkeletonJson.c:				spAttachmentTimeline *timeline = spAttachmentTimeline_create(timelineArray->size);
spine-c/src/spine/SkeletonJson.c:				timeline->slotIndex = slotIndex;
spine-c/src/spine/SkeletonJson.c:				for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:							name->type == Json_NULL ? 0 : name->valueString);
spine-c/src/spine/SkeletonJson.c:				animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:				duration = timeline->frames[timelineArray->size - 1];
spine-c/src/spine/SkeletonJson.c:				if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:				_spSkeletonJson_setError(self, 0, "Invalid timeline type for a slot: ", timelineArray->name);
spine-c/src/spine/SkeletonJson.c:	for (boneMap = bones ? bones->child : 0; boneMap; boneMap = boneMap->next) {
spine-c/src/spine/SkeletonJson.c:		int boneIndex = spSkeletonData_findBoneIndex(skeletonData, boneMap->name);
spine-c/src/spine/SkeletonJson.c:		if (boneIndex == -1) {
spine-c/src/spine/SkeletonJson.c:			_spSkeletonJson_setError(self, root, "Bone not found: ", boneMap->name);
spine-c/src/spine/SkeletonJson.c:		for (timelineArray = boneMap->child; timelineArray; timelineArray = timelineArray->next) {
spine-c/src/spine/SkeletonJson.c:			if (strcmp(timelineArray->name, "rotate") == 0) {
spine-c/src/spine/SkeletonJson.c:				spRotateTimeline *timeline = spRotateTimeline_create(timelineArray->size);
spine-c/src/spine/SkeletonJson.c:				timeline->boneIndex = boneIndex;
spine-c/src/spine/SkeletonJson.c:				for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:				animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:				duration = timeline->frames[timelineArray->size * 2 - 2];
spine-c/src/spine/SkeletonJson.c:				if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:				int isScale = strcmp(timelineArray->name, "scale") == 0;
spine-c/src/spine/SkeletonJson.c:				if (isScale || strcmp(timelineArray->name, "translate") == 0) {
spine-c/src/spine/SkeletonJson.c:					float scale = isScale ? 1 : self->scale;
spine-c/src/spine/SkeletonJson.c:							isScale ? spScaleTimeline_create(timelineArray->size) : spTranslateTimeline_create(timelineArray->size);
spine-c/src/spine/SkeletonJson.c:					timeline->boneIndex = boneIndex;
spine-c/src/spine/SkeletonJson.c:					for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:					animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:					duration = timeline->frames[timelineArray->size * 3 - 3];
spine-c/src/spine/SkeletonJson.c:					if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:				} else if (strcmp(timelineArray->name, "flipX") == 0 || strcmp(timelineArray->name, "flipY") == 0) {
spine-c/src/spine/SkeletonJson.c:					int x = strcmp(timelineArray->name, "flipX") == 0;
spine-c/src/spine/SkeletonJson.c:					spFlipTimeline *timeline = spFlipTimeline_create(timelineArray->size, x);
spine-c/src/spine/SkeletonJson.c:					timeline->boneIndex = boneIndex;
spine-c/src/spine/SkeletonJson.c:					for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i)
spine-c/src/spine/SkeletonJson.c:					animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:					duration = timeline->frames[timelineArray->size * 2 - 2];
spine-c/src/spine/SkeletonJson.c:					if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:					_spSkeletonJson_setError(self, 0, "Invalid timeline type for a bone: ", timelineArray->name);
spine-c/src/spine/SkeletonJson.c:	for (ikMap = ik ? ik->child : 0; ikMap; ikMap = ikMap->next) {
spine-c/src/spine/SkeletonJson.c:		spIkConstraintData* ikConstraint = spSkeletonData_findIkConstraint(skeletonData, ikMap->name);
spine-c/src/spine/SkeletonJson.c:		spIkConstraintTimeline* timeline = spIkConstraintTimeline_create(ikMap->size);
spine-c/src/spine/SkeletonJson.c:		for (i = 0; i < skeletonData->ikConstraintsCount; ++i) {
spine-c/src/spine/SkeletonJson.c:			if (ikConstraint == skeletonData->ikConstraints[i]) {
spine-c/src/spine/SkeletonJson.c:				timeline->ikConstraintIndex = i;
spine-c/src/spine/SkeletonJson.c:		for (frame = ikMap->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:					Json_getInt(frame, "bendPositive", 1) ? 1 : -1);
spine-c/src/spine/SkeletonJson.c:		animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:		duration = timeline->frames[ikMap->size * 3 - 3];
spine-c/src/spine/SkeletonJson.c:		if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:	for (ffdMap = ffd ? ffd->child : 0; ffdMap; ffdMap = ffdMap->next) {
spine-c/src/spine/SkeletonJson.c:		spSkin* skin = spSkeletonData_findSkin(skeletonData, ffdMap->name);
spine-c/src/spine/SkeletonJson.c:		for (slotMap = ffdMap->child; slotMap; slotMap = slotMap->next) {
spine-c/src/spine/SkeletonJson.c:			int slotIndex = spSkeletonData_findSlotIndex(skeletonData, slotMap->name);
spine-c/src/spine/SkeletonJson.c:			for (timelineArray = slotMap->child; timelineArray; timelineArray = timelineArray->next) {
spine-c/src/spine/SkeletonJson.c:				spAttachment* attachment = spSkin_getAttachment(skin, slotIndex, timelineArray->name);
spine-c/src/spine/SkeletonJson.c:					_spSkeletonJson_setError(self, 0, "Attachment not found: ", timelineArray->name);
spine-c/src/spine/SkeletonJson.c:				if (attachment->type == SP_ATTACHMENT_MESH)
spine-c/src/spine/SkeletonJson.c:					verticesCount = SUB_CAST(spMeshAttachment, attachment)->verticesCount;
spine-c/src/spine/SkeletonJson.c:				else if (attachment->type == SP_ATTACHMENT_SKINNED_MESH)
spine-c/src/spine/SkeletonJson.c:					verticesCount = SUB_CAST(spSkinnedMeshAttachment, attachment)->weightsCount / 3 * 2;
spine-c/src/spine/SkeletonJson.c:				timeline = spFFDTimeline_create(timelineArray->size, verticesCount);
spine-c/src/spine/SkeletonJson.c:				timeline->slotIndex = slotIndex;
spine-c/src/spine/SkeletonJson.c:				timeline->attachment = attachment;
spine-c/src/spine/SkeletonJson.c:				for (frame = timelineArray->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:						if (attachment->type == SP_ATTACHMENT_MESH)
spine-c/src/spine/SkeletonJson.c:							frameVertices = SUB_CAST(spMeshAttachment, attachment)->vertices;
spine-c/src/spine/SkeletonJson.c:						if (self->scale == 1) {
spine-c/src/spine/SkeletonJson.c:							for (vertex = vertices->child, v = start; vertex; vertex = vertex->next, ++v)
spine-c/src/spine/SkeletonJson.c:								frameVertices[v] = vertex->valueFloat;
spine-c/src/spine/SkeletonJson.c:							for (vertex = vertices->child, v = start; vertex; vertex = vertex->next, ++v)
spine-c/src/spine/SkeletonJson.c:								frameVertices[v] = vertex->valueFloat * self->scale;
spine-c/src/spine/SkeletonJson.c:						memset(frameVertices + v, 0, sizeof(float) * (verticesCount - v));
spine-c/src/spine/SkeletonJson.c:						if (attachment->type == SP_ATTACHMENT_MESH) {
spine-c/src/spine/SkeletonJson.c:							float* meshVertices = SUB_CAST(spMeshAttachment, attachment)->vertices;
spine-c/src/spine/SkeletonJson.c:				animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:				duration = timeline->frames[timelineArray->size - 1];
spine-c/src/spine/SkeletonJson.c:				if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:		spDrawOrderTimeline* timeline = spDrawOrderTimeline_create(drawOrder->size, skeletonData->slotsCount);
spine-c/src/spine/SkeletonJson.c:		for (frame = drawOrder->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:				int* unchanged = MALLOC(int, skeletonData->slotsCount - offsets->size);
spine-c/src/spine/SkeletonJson.c:				drawOrder = MALLOC(int, skeletonData->slotsCount);
spine-c/src/spine/SkeletonJson.c:				for (ii = skeletonData->slotsCount - 1; ii >= 0; --ii)
spine-c/src/spine/SkeletonJson.c:					drawOrder[ii] = -1;
spine-c/src/spine/SkeletonJson.c:				for (offsetMap = offsets->child; offsetMap; offsetMap = offsetMap->next) {
spine-c/src/spine/SkeletonJson.c:					if (slotIndex == -1) {
spine-c/src/spine/SkeletonJson.c:				while (originalIndex < skeletonData->slotsCount)
spine-c/src/spine/SkeletonJson.c:				for (ii = skeletonData->slotsCount - 1; ii >= 0; ii--)
spine-c/src/spine/SkeletonJson.c:					if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
spine-c/src/spine/SkeletonJson.c:		animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:		duration = timeline->frames[drawOrder->size - 1];
spine-c/src/spine/SkeletonJson.c:		if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:		spEventTimeline* timeline = spEventTimeline_create(events->size);
spine-c/src/spine/SkeletonJson.c:		for (frame = events->child, i = 0; frame; frame = frame->next, ++i) {
spine-c/src/spine/SkeletonJson.c:			event->intValue = Json_getInt(frame, "int", eventData->intValue);
spine-c/src/spine/SkeletonJson.c:			event->floatValue = Json_getFloat(frame, "float", eventData->floatValue);
spine-c/src/spine/SkeletonJson.c:			stringValue = Json_getString(frame, "string", eventData->stringValue);
spine-c/src/spine/SkeletonJson.c:			if (stringValue) MALLOC_STR(event->stringValue, stringValue);
spine-c/src/spine/SkeletonJson.c:		animation->timelines[animation->timelinesCount++] = SUPER_CAST(spTimeline, timeline);
spine-c/src/spine/SkeletonJson.c:		duration = timeline->frames[events->size - 1];
spine-c/src/spine/SkeletonJson.c:		if (duration > animation->duration) animation->duration = duration;
spine-c/src/spine/SkeletonJson.c:	FREE(self->error);
spine-c/src/spine/SkeletonJson.c:	CONST_CAST(char*, self->error) = 0;
spine-c/src/spine/SkeletonJson.c:		MALLOC_STR(skeletonData->hash, Json_getString(skeleton, "hash", 0));
spine-c/src/spine/SkeletonJson.c:		MALLOC_STR(skeletonData->version,  Json_getString(skeleton, "spine", 0));
spine-c/src/spine/SkeletonJson.c:		skeletonData->width = Json_getFloat(skeleton, "width", 0);
spine-c/src/spine/SkeletonJson.c:		skeletonData->height = Json_getFloat(skeleton, "height", 0);
spine-c/src/spine/SkeletonJson.c:	skeletonData->bones = MALLOC(spBoneData*, bones->size);
spine-c/src/spine/SkeletonJson.c:	for (boneMap = bones->child, i = 0; boneMap; boneMap = boneMap->next, ++i) {
spine-c/src/spine/SkeletonJson.c:		boneData->length = Json_getFloat(boneMap, "length", 0) * self->scale;
spine-c/src/spine/SkeletonJson.c:		boneData->x = Json_getFloat(boneMap, "x", 0) * self->scale;
spine-c/src/spine/SkeletonJson.c:		boneData->y = Json_getFloat(boneMap, "y", 0) * self->scale;
spine-c/src/spine/SkeletonJson.c:		boneData->rotation = Json_getFloat(boneMap, "rotation", 0);
spine-c/src/spine/SkeletonJson.c:		boneData->scaleX = Json_getFloat(boneMap, "scaleX", 1);
spine-c/src/spine/SkeletonJson.c:		boneData->scaleY = Json_getFloat(boneMap, "scaleY", 1);
spine-c/src/spine/SkeletonJson.c:		boneData->inheritScale = Json_getInt(boneMap, "inheritScale", 1);
spine-c/src/spine/SkeletonJson.c:		boneData->inheritRotation = Json_getInt(boneMap, "inheritRotation", 1);
spine-c/src/spine/SkeletonJson.c:		boneData->flipX = Json_getInt(boneMap, "flipX", 0);
spine-c/src/spine/SkeletonJson.c:		boneData->flipY = Json_getInt(boneMap, "flipY", 0);
spine-c/src/spine/SkeletonJson.c:		skeletonData->bones[i] = boneData;
spine-c/src/spine/SkeletonJson.c:		skeletonData->bonesCount++;
spine-c/src/spine/SkeletonJson.c:		skeletonData->ikConstraintsCount = ik->size;
spine-c/src/spine/SkeletonJson.c:		skeletonData->ikConstraints = MALLOC(spIkConstraintData*, ik->size);
spine-c/src/spine/SkeletonJson.c:		for (ikMap = ik->child, i = 0; ikMap; ikMap = ikMap->next, ++i) {
spine-c/src/spine/SkeletonJson.c:			ikConstraintData->bonesCount = boneMap->size;
spine-c/src/spine/SkeletonJson.c:			ikConstraintData->bones = MALLOC(spBoneData*, boneMap->size);
spine-c/src/spine/SkeletonJson.c:			for (boneMap = boneMap->child, ii = 0; boneMap; boneMap = boneMap->next, ++ii) {
spine-c/src/spine/SkeletonJson.c:				ikConstraintData->bones[ii] = spSkeletonData_findBone(skeletonData, boneMap->valueString);
spine-c/src/spine/SkeletonJson.c:				if (!ikConstraintData->bones[ii]) {
spine-c/src/spine/SkeletonJson.c:					_spSkeletonJson_setError(self, root, "IK bone not found: ", boneMap->valueString);
spine-c/src/spine/SkeletonJson.c:			ikConstraintData->target = spSkeletonData_findBone(skeletonData, targetName);
spine-c/src/spine/SkeletonJson.c:			if (!ikConstraintData->target) {
spine-c/src/spine/SkeletonJson.c:				_spSkeletonJson_setError(self, root, "Target bone not found: ", boneMap->name);
spine-c/src/spine/SkeletonJson.c:			ikConstraintData->bendDirection = Json_getInt(ikMap, "bendPositive", 1) ? 1 : -1;
spine-c/src/spine/SkeletonJson.c:			ikConstraintData->mix = Json_getFloat(ikMap, "mix", 1);
spine-c/src/spine/SkeletonJson.c:			skeletonData->ikConstraints[i] = ikConstraintData;
spine-c/src/spine/SkeletonJson.c:		skeletonData->slotsCount = slots->size;
spine-c/src/spine/SkeletonJson.c:		skeletonData->slots = MALLOC(spSlotData*, slots->size);
spine-c/src/spine/SkeletonJson.c:		for (slotMap = slots->child, i = 0; slotMap; slotMap = slotMap->next, ++i) {
spine-c/src/spine/SkeletonJson.c:				slotData->r = toColor(color, 0);
spine-c/src/spine/SkeletonJson.c:				slotData->g = toColor(color, 1);
spine-c/src/spine/SkeletonJson.c:				slotData->b = toColor(color, 2);
spine-c/src/spine/SkeletonJson.c:				slotData->a = toColor(color, 3);
spine-c/src/spine/SkeletonJson.c:			if (item) spSlotData_setAttachmentName(slotData, item->valueString);
spine-c/src/spine/SkeletonJson.c:				if (strcmp(item->valueString, "additive") == 0)
spine-c/src/spine/SkeletonJson.c:					slotData->blendMode = SP_BLEND_MODE_ADDITIVE;
spine-c/src/spine/SkeletonJson.c:				else if (strcmp(item->valueString, "multiply") == 0)
spine-c/src/spine/SkeletonJson.c:					slotData->blendMode = SP_BLEND_MODE_MULTIPLY;
spine-c/src/spine/SkeletonJson.c:				else if (strcmp(item->valueString, "screen") == 0)
spine-c/src/spine/SkeletonJson.c:					slotData->blendMode = SP_BLEND_MODE_SCREEN;
spine-c/src/spine/SkeletonJson.c:			skeletonData->slots[i] = slotData;
spine-c/src/spine/SkeletonJson.c:		skeletonData->skinsCount = skins->size;
spine-c/src/spine/SkeletonJson.c:		skeletonData->skins = MALLOC(spSkin*, skins->size);
spine-c/src/spine/SkeletonJson.c:		for (slotMap = skins->child, i = 0; slotMap; slotMap = slotMap->next, ++i) {
spine-c/src/spine/SkeletonJson.c:			spSkin *skin = spSkin_create(slotMap->name);
spine-c/src/spine/SkeletonJson.c:			skeletonData->skins[i] = skin;
spine-c/src/spine/SkeletonJson.c:			if (strcmp(slotMap->name, "default") == 0) skeletonData->defaultSkin = skin;
spine-c/src/spine/SkeletonJson.c:			for (attachmentsMap = slotMap->child; attachmentsMap; attachmentsMap = attachmentsMap->next) {
spine-c/src/spine/SkeletonJson.c:				int slotIndex = spSkeletonData_findSlotIndex(skeletonData, attachmentsMap->name);
spine-c/src/spine/SkeletonJson.c:				for (attachmentMap = attachmentsMap->child; attachmentMap; attachmentMap = attachmentMap->next) {
spine-c/src/spine/SkeletonJson.c:					const char* skinAttachmentName = attachmentMap->name;
spine-c/src/spine/SkeletonJson.c:					attachment = spAttachmentLoader_newAttachment(self->attachmentLoader, skin, type, attachmentName, path);
spine-c/src/spine/SkeletonJson.c:						if (self->attachmentLoader->error1) {
spine-c/src/spine/SkeletonJson.c:							_spSkeletonJson_setError(self, root, self->attachmentLoader->error1, self->attachmentLoader->error2);
spine-c/src/spine/SkeletonJson.c:					switch (attachment->type) {
spine-c/src/spine/SkeletonJson.c:						if (path) MALLOC_STR(region->path, path);
spine-c/src/spine/SkeletonJson.c:						region->x = Json_getFloat(attachmentMap, "x", 0) * self->scale;
spine-c/src/spine/SkeletonJson.c:						region->y = Json_getFloat(attachmentMap, "y", 0) * self->scale;
spine-c/src/spine/SkeletonJson.c:						region->scaleX = Json_getFloat(attachmentMap, "scaleX", 1);
spine-c/src/spine/SkeletonJson.c:						region->scaleY = Json_getFloat(attachmentMap, "scaleY", 1);
spine-c/src/spine/SkeletonJson.c:						region->rotation = Json_getFloat(attachmentMap, "rotation", 0);
spine-c/src/spine/SkeletonJson.c:						region->width = Json_getFloat(attachmentMap, "width", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:						region->height = Json_getFloat(attachmentMap, "height", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:							region->r = toColor(color, 0);
spine-c/src/spine/SkeletonJson.c:							region->g = toColor(color, 1);
spine-c/src/spine/SkeletonJson.c:							region->b = toColor(color, 2);
spine-c/src/spine/SkeletonJson.c:							region->a = toColor(color, 3);
spine-c/src/spine/SkeletonJson.c:						MALLOC_STR(mesh->path, path);
spine-c/src/spine/SkeletonJson.c:						mesh->verticesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						mesh->vertices = MALLOC(float, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							mesh->vertices[i] = entry->valueFloat * self->scale;
spine-c/src/spine/SkeletonJson.c:						mesh->trianglesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						mesh->triangles = MALLOC(int, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							mesh->triangles[i] = entry->valueInt;
spine-c/src/spine/SkeletonJson.c:						mesh->regionUVs = MALLOC(float, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							mesh->regionUVs[i] = entry->valueFloat;
spine-c/src/spine/SkeletonJson.c:							mesh->r = toColor(color, 0);
spine-c/src/spine/SkeletonJson.c:							mesh->g = toColor(color, 1);
spine-c/src/spine/SkeletonJson.c:							mesh->b = toColor(color, 2);
spine-c/src/spine/SkeletonJson.c:							mesh->a = toColor(color, 3);
spine-c/src/spine/SkeletonJson.c:						mesh->hullLength = Json_getInt(attachmentMap, "hull", 0);
spine-c/src/spine/SkeletonJson.c:							mesh->edgesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:							mesh->edges = MALLOC(int, entry->size);
spine-c/src/spine/SkeletonJson.c:							for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:								mesh->edges[i] = entry->valueInt;
spine-c/src/spine/SkeletonJson.c:						mesh->width = Json_getFloat(attachmentMap, "width", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:						mesh->height = Json_getFloat(attachmentMap, "height", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:						MALLOC_STR(mesh->path, path);
spine-c/src/spine/SkeletonJson.c:						mesh->uvsCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						mesh->regionUVs = MALLOC(float, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							mesh->regionUVs[i] = entry->valueFloat;
spine-c/src/spine/SkeletonJson.c:						verticesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						vertices = MALLOC(float, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							vertices[i] = entry->valueFloat;
spine-c/src/spine/SkeletonJson.c:							mesh->bonesCount += bonesCount + 1;
spine-c/src/spine/SkeletonJson.c:							mesh->weightsCount += bonesCount * 3;
spine-c/src/spine/SkeletonJson.c:						mesh->bones = MALLOC(int, mesh->bonesCount);
spine-c/src/spine/SkeletonJson.c:						mesh->weights = MALLOC(float, mesh->weightsCount);
spine-c/src/spine/SkeletonJson.c:							mesh->bones[b++] = bonesCount;
spine-c/src/spine/SkeletonJson.c:								mesh->bones[b] = (int)vertices[i];
spine-c/src/spine/SkeletonJson.c:								mesh->weights[w] = vertices[i + 1] * self->scale;
spine-c/src/spine/SkeletonJson.c:								mesh->weights[w + 1] = vertices[i + 2] * self->scale;
spine-c/src/spine/SkeletonJson.c:								mesh->weights[w + 2] = vertices[i + 3];
spine-c/src/spine/SkeletonJson.c:						mesh->trianglesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						mesh->triangles = MALLOC(int, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							mesh->triangles[i] = entry->valueInt;
spine-c/src/spine/SkeletonJson.c:							mesh->r = toColor(color, 0);
spine-c/src/spine/SkeletonJson.c:							mesh->g = toColor(color, 1);
spine-c/src/spine/SkeletonJson.c:							mesh->b = toColor(color, 2);
spine-c/src/spine/SkeletonJson.c:							mesh->a = toColor(color, 3);
spine-c/src/spine/SkeletonJson.c:						mesh->hullLength = Json_getInt(attachmentMap, "hull", 0);
spine-c/src/spine/SkeletonJson.c:							mesh->edgesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:							mesh->edges = MALLOC(int, entry->size);
spine-c/src/spine/SkeletonJson.c:							for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:								mesh->edges[i] = entry->valueInt;
spine-c/src/spine/SkeletonJson.c:						mesh->width = Json_getFloat(attachmentMap, "width", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:						mesh->height = Json_getFloat(attachmentMap, "height", 32) * self->scale;
spine-c/src/spine/SkeletonJson.c:						box->verticesCount = entry->size;
spine-c/src/spine/SkeletonJson.c:						box->vertices = MALLOC(float, entry->size);
spine-c/src/spine/SkeletonJson.c:						for (entry = entry->child, i = 0; entry; entry = entry->next, ++i)
spine-c/src/spine/SkeletonJson.c:							box->vertices[i] = entry->valueFloat * self->scale;
spine-c/src/spine/SkeletonJson.c:		skeletonData->eventsCount = events->size;
spine-c/src/spine/SkeletonJson.c:		skeletonData->events = MALLOC(spEventData*, events->size);
spine-c/src/spine/SkeletonJson.c:		for (eventMap = events->child, i = 0; eventMap; eventMap = eventMap->next, ++i) {
spine-c/src/spine/SkeletonJson.c:			spEventData* eventData = spEventData_create(eventMap->name);
spine-c/src/spine/SkeletonJson.c:			eventData->intValue = Json_getInt(eventMap, "int", 0);
spine-c/src/spine/SkeletonJson.c:			eventData->floatValue = Json_getFloat(eventMap, "float", 0);
spine-c/src/spine/SkeletonJson.c:			if (stringValue) MALLOC_STR(eventData->stringValue, stringValue);
spine-c/src/spine/SkeletonJson.c:			skeletonData->events[i] = eventData;
spine-c/src/spine/SkeletonJson.c:		skeletonData->animations = MALLOC(spAnimation*, animations->size);
spine-c/src/spine/SkeletonJson.c:		for (animationMap = animations->child; animationMap; animationMap = animationMap->next)
spine-c/src/spine/Atlas.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Atlas.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Atlas.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Atlas.c:	CONST_CAST(spAtlas*, self->atlas) = atlas;
spine-c/src/spine/Atlas.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/Atlas.c:	FREE(self->name);
spine-c/src/spine/Atlas.c:	FREE(self->name);
spine-c/src/spine/Atlas.c:	FREE(self->splits);
spine-c/src/spine/Atlas.c:	FREE(self->pads);
spine-c/src/spine/Atlas.c:	while (isspace(*str->begin) && str->begin < str->end)
spine-c/src/spine/Atlas.c:		(str->begin)++;
spine-c/src/spine/Atlas.c:	if (str->begin == str->end) return;
spine-c/src/spine/Atlas.c:	str->end--;
spine-c/src/spine/Atlas.c:	while (isspace(*str->end) && str->end >= str->begin)
spine-c/src/spine/Atlas.c:		str->end--;
spine-c/src/spine/Atlas.c:	str->end++;
spine-c/src/spine/Atlas.c:	str->begin = *begin;
spine-c/src/spine/Atlas.c:	str->end = *begin;
spine-c/src/spine/Atlas.c:/* Moves str->begin past the first occurence of c. Returns 0 on failure. */
spine-c/src/spine/Atlas.c:	const char* begin = str->begin;
spine-c/src/spine/Atlas.c:		if (begin == str->end) return 0;
spine-c/src/spine/Atlas.c:	str->begin = begin;
spine-c/src/spine/Atlas.c:		tuple[i].end = str.begin - 2;
spine-c/src/spine/Atlas.c:	int length = (int)(str->end - str->begin);
spine-c/src/spine/Atlas.c:	memcpy(string, str->begin, length);
spine-c/src/spine/Atlas.c:	int length = (int)(str->end - str->begin);
spine-c/src/spine/Atlas.c:	for (i = count - 1; i >= 0; i--)
spine-c/src/spine/Atlas.c:		if (strncmp(array[i], str->begin, length) == 0) return i;
spine-c/src/spine/Atlas.c:	return -1;
spine-c/src/spine/Atlas.c:	return strncmp(other, str->begin, str->end - str->begin) == 0;
spine-c/src/spine/Atlas.c:	return (int)strtol(str->begin, (char**)&str->end, 10);
spine-c/src/spine/Atlas.c:	int needsSlash = dirLength > 0 && dir[dirLength - 1] != '/' && dir[dirLength - 1] != '\\';
spine-c/src/spine/Atlas.c:	self->rendererObject = rendererObject;
spine-c/src/spine/Atlas.c:		if (str.end - str.begin == 0) {
spine-c/src/spine/Atlas.c:				lastPage->next = page;
spine-c/src/spine/Atlas.c:				self->pages = page;
spine-c/src/spine/Atlas.c:				page->width = toInt(tuple);
spine-c/src/spine/Atlas.c:				page->height = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:			page->format = (spAtlasFormat)indexOf(formatNames, 7, tuple);
spine-c/src/spine/Atlas.c:			page->minFilter = (spAtlasFilter)indexOf(textureFilterNames, 7, tuple);
spine-c/src/spine/Atlas.c:			page->magFilter = (spAtlasFilter)indexOf(textureFilterNames, 7, tuple + 1);
spine-c/src/spine/Atlas.c:				page->uWrap = *str.begin == 'x' ? SP_ATLAS_REPEAT : (*str.begin == 'y' ? SP_ATLAS_CLAMPTOEDGE : SP_ATLAS_REPEAT);
spine-c/src/spine/Atlas.c:				page->vWrap = *str.begin == 'x' ? SP_ATLAS_CLAMPTOEDGE : (*str.begin == 'y' ? SP_ATLAS_REPEAT : SP_ATLAS_REPEAT);
spine-c/src/spine/Atlas.c:				lastRegion->next = region;
spine-c/src/spine/Atlas.c:				self->regions = region;
spine-c/src/spine/Atlas.c:			region->page = page;
spine-c/src/spine/Atlas.c:			region->name = mallocString(&str);
spine-c/src/spine/Atlas.c:			region->rotate = equals(&str, "true");
spine-c/src/spine/Atlas.c:			region->x = toInt(tuple);
spine-c/src/spine/Atlas.c:			region->y = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:			region->width = toInt(tuple);
spine-c/src/spine/Atlas.c:			region->height = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:			region->u = region->x / (float)page->width;
spine-c/src/spine/Atlas.c:			region->v = region->y / (float)page->height;
spine-c/src/spine/Atlas.c:			if (region->rotate) {
spine-c/src/spine/Atlas.c:				region->u2 = (region->x + region->height) / (float)page->width;
spine-c/src/spine/Atlas.c:				region->v2 = (region->y + region->width) / (float)page->height;
spine-c/src/spine/Atlas.c:				region->u2 = (region->x + region->width) / (float)page->width;
spine-c/src/spine/Atlas.c:				region->v2 = (region->y + region->height) / (float)page->height;
spine-c/src/spine/Atlas.c:				region->splits = MALLOC(int, 4);
spine-c/src/spine/Atlas.c:				region->splits[0] = toInt(tuple);
spine-c/src/spine/Atlas.c:				region->splits[1] = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:				region->splits[2] = toInt(tuple + 2);
spine-c/src/spine/Atlas.c:				region->splits[3] = toInt(tuple + 3);
spine-c/src/spine/Atlas.c:					region->pads = MALLOC(int, 4);
spine-c/src/spine/Atlas.c:					region->pads[0] = toInt(tuple);
spine-c/src/spine/Atlas.c:					region->pads[1] = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:					region->pads[2] = toInt(tuple + 2);
spine-c/src/spine/Atlas.c:					region->pads[3] = toInt(tuple + 3);
spine-c/src/spine/Atlas.c:			region->originalWidth = toInt(tuple);
spine-c/src/spine/Atlas.c:			region->originalHeight = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:			region->offsetX = toInt(tuple);
spine-c/src/spine/Atlas.c:			region->offsetY = toInt(tuple + 1);
spine-c/src/spine/Atlas.c:			region->index = toInt(&str);
spine-c/src/spine/Atlas.c:	dirLength = (int)(lastSlash ? lastSlash - path : 0);
spine-c/src/spine/Atlas.c:	spAtlasPage* page = self->pages;
spine-c/src/spine/Atlas.c:		spAtlasPage* nextPage = page->next;
spine-c/src/spine/Atlas.c:	region = self->regions;
spine-c/src/spine/Atlas.c:		nextRegion = region->next;
spine-c/src/spine/Atlas.c:	spAtlasRegion* region = self->regions;
spine-c/src/spine/Atlas.c:		if (strcmp(region->name, name) == 0) return region;
spine-c/src/spine/Atlas.c:		region = region->next;
spine-c/src/spine/Event.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Event.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Event.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Event.c:	CONST_CAST(spEventData*, self->data) = data;
spine-c/src/spine/Event.c:	FREE(self->stringValue);
spine-c/src/spine/AnimationState.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/AnimationState.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/AnimationState.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/AnimationState.c:	CONST_CAST(spAnimationState*, self->state) = state;
spine-c/src/spine/AnimationState.c:	self->timeScale = 1;
spine-c/src/spine/AnimationState.c:	self->lastTime = -1;
spine-c/src/spine/AnimationState.c:	self->mix = 1;
spine-c/src/spine/AnimationState.c:	if (self->previous) SUB_CAST(_spAnimationState, self->state)->disposeTrackEntry(self->previous);
spine-c/src/spine/AnimationState.c:	internal->events = MALLOC(spEvent*, 64);
spine-c/src/spine/AnimationState.c:	self->timeScale = 1;
spine-c/src/spine/AnimationState.c:	CONST_CAST(spAnimationStateData*, self->data) = data;
spine-c/src/spine/AnimationState.c:	internal->createTrackEntry = _spAnimationState_createTrackEntry;
spine-c/src/spine/AnimationState.c:	internal->disposeTrackEntry = _spAnimationState_disposeTrackEntry;
spine-c/src/spine/AnimationState.c:		spTrackEntry* next = entry->next;
spine-c/src/spine/AnimationState.c:		internal->disposeTrackEntry(entry);
spine-c/src/spine/AnimationState.c:	FREE(internal->events);
spine-c/src/spine/AnimationState.c:	for (i = 0; i < self->tracksCount; ++i)
spine-c/src/spine/AnimationState.c:		_spAnimationState_disposeAllEntries(self, self->tracks[i]);
spine-c/src/spine/AnimationState.c:	FREE(self->tracks);
spine-c/src/spine/AnimationState.c:	delta *= self->timeScale;
spine-c/src/spine/AnimationState.c:	for (i = 0; i < self->tracksCount; ++i) {
spine-c/src/spine/AnimationState.c:		spTrackEntry* current = self->tracks[i];
spine-c/src/spine/AnimationState.c:		current->time += delta * current->timeScale;
spine-c/src/spine/AnimationState.c:		if (current->previous) {
spine-c/src/spine/AnimationState.c:			previousDelta = delta * current->previous->timeScale;
spine-c/src/spine/AnimationState.c:			current->previous->time += previousDelta;
spine-c/src/spine/AnimationState.c:			current->mixTime += previousDelta;
spine-c/src/spine/AnimationState.c:		if (current->next) {
spine-c/src/spine/AnimationState.c:			current->next->time = current->lastTime - current->next->delay;
spine-c/src/spine/AnimationState.c:			if (current->next->time >= 0) _spAnimationState_setCurrent(self, i, current->next);
spine-c/src/spine/AnimationState.c:			/* End non-looping animation when it reaches its end time and there is no next entry. */
spine-c/src/spine/AnimationState.c:			if (!current->loop && current->lastTime >= current->endTime) spAnimationState_clearTrack(self, i);
spine-c/src/spine/AnimationState.c:	for (i = 0; i < self->tracksCount; ++i) {
spine-c/src/spine/AnimationState.c:		spTrackEntry* current = self->tracks[i];
spine-c/src/spine/AnimationState.c:		time = current->time;
spine-c/src/spine/AnimationState.c:		if (!current->loop && time > current->endTime) time = current->endTime;
spine-c/src/spine/AnimationState.c:		previous = current->previous;
spine-c/src/spine/AnimationState.c:			if (current->mix == 1) {
spine-c/src/spine/AnimationState.c:				spAnimation_apply(current->animation, skeleton, current->lastTime, time,
spine-c/src/spine/AnimationState.c:					current->loop, internal->events, &eventsCount);
spine-c/src/spine/AnimationState.c:				spAnimation_mix(current->animation, skeleton, current->lastTime, time,
spine-c/src/spine/AnimationState.c:					current->loop, internal->events, &eventsCount, current->mix);
spine-c/src/spine/AnimationState.c:			float alpha = current->mixTime / current->mixDuration * current->mix;
spine-c/src/spine/AnimationState.c:			float previousTime = previous->time;
spine-c/src/spine/AnimationState.c:			if (!previous->loop && previousTime > previous->endTime) previousTime = previous->endTime;
spine-c/src/spine/AnimationState.c:			spAnimation_apply(previous->animation, skeleton, previousTime, previousTime, previous->loop, 0, 0);
spine-c/src/spine/AnimationState.c:				internal->disposeTrackEntry(current->previous);
spine-c/src/spine/AnimationState.c:				current->previous = 0;
spine-c/src/spine/AnimationState.c:			spAnimation_mix(current->animation, skeleton, current->lastTime, time,
spine-c/src/spine/AnimationState.c:				current->loop, internal->events, &eventsCount, alpha);
spine-c/src/spine/AnimationState.c:			spEvent* event = internal->events[ii];
spine-c/src/spine/AnimationState.c:			if (current->listener) {
spine-c/src/spine/AnimationState.c:				current->listener(self, i, SP_ANIMATION_EVENT, event, 0);
spine-c/src/spine/AnimationState.c:				if (self->tracks[i] != current) {
spine-c/src/spine/AnimationState.c:			if (self->listener) {
spine-c/src/spine/AnimationState.c:				self->listener(self, i, SP_ANIMATION_EVENT, event, 0);
spine-c/src/spine/AnimationState.c:				if (self->tracks[i] != current) {
spine-c/src/spine/AnimationState.c:		if (current->loop ? (FMOD(current->lastTime, current->endTime) > FMOD(time, current->endTime))
spine-c/src/spine/AnimationState.c:				: (current->lastTime < current->endTime && time >= current->endTime)) {
spine-c/src/spine/AnimationState.c:			int count = (int)(time / current->endTime);
spine-c/src/spine/AnimationState.c:			if (current->listener) {
spine-c/src/spine/AnimationState.c:				current->listener(self, i, SP_ANIMATION_COMPLETE, 0, count);
spine-c/src/spine/AnimationState.c:				if (self->tracks[i] != current) continue;
spine-c/src/spine/AnimationState.c:			if (self->listener) {
spine-c/src/spine/AnimationState.c:				self->listener(self, i, SP_ANIMATION_COMPLETE, 0, count);
spine-c/src/spine/AnimationState.c:				if (self->tracks[i] != current) continue;
spine-c/src/spine/AnimationState.c:		current->lastTime = current->time;
spine-c/src/spine/AnimationState.c:	for (i = 0; i < self->tracksCount; ++i)
spine-c/src/spine/AnimationState.c:	self->tracksCount = 0;
spine-c/src/spine/AnimationState.c:	if (trackIndex >= self->tracksCount) return;
spine-c/src/spine/AnimationState.c:	current = self->tracks[trackIndex];
spine-c/src/spine/AnimationState.c:	if (current->listener) current->listener(self, trackIndex, SP_ANIMATION_END, 0, 0);
spine-c/src/spine/AnimationState.c:	if (self->listener) self->listener(self, trackIndex, SP_ANIMATION_END, 0, 0);
spine-c/src/spine/AnimationState.c:	self->tracks[trackIndex] = 0;
spine-c/src/spine/AnimationState.c:	if (index < self->tracksCount) return self->tracks[index];
spine-c/src/spine/AnimationState.c:	memcpy(newTracks, self->tracks, self->tracksCount * sizeof(spTrackEntry*));
spine-c/src/spine/AnimationState.c:	FREE(self->tracks);
spine-c/src/spine/AnimationState.c:	self->tracks = newTracks;
spine-c/src/spine/AnimationState.c:	self->tracksCount = index + 1;
spine-c/src/spine/AnimationState.c:		spTrackEntry* previous = current->previous;
spine-c/src/spine/AnimationState.c:		current->previous = 0;
spine-c/src/spine/AnimationState.c:		if (current->listener) current->listener(self, index, SP_ANIMATION_END, 0, 0);
spine-c/src/spine/AnimationState.c:		if (self->listener) self->listener(self, index, SP_ANIMATION_END, 0, 0);
spine-c/src/spine/AnimationState.c:		entry->mixDuration = spAnimationStateData_getMix(self->data, current->animation, entry->animation);
spine-c/src/spine/AnimationState.c:		if (entry->mixDuration > 0) {
spine-c/src/spine/AnimationState.c:			entry->mixTime = 0;
spine-c/src/spine/AnimationState.c:			if (previous && current->mixTime / current->mixDuration < 0.5f) {
spine-c/src/spine/AnimationState.c:				entry->previous = previous;
spine-c/src/spine/AnimationState.c:				entry->previous = current;
spine-c/src/spine/AnimationState.c:			internal->disposeTrackEntry(current);
spine-c/src/spine/AnimationState.c:		if (previous) internal->disposeTrackEntry(previous);
spine-c/src/spine/AnimationState.c:	self->tracks[index] = entry;
spine-c/src/spine/AnimationState.c:	if (entry->listener) {
spine-c/src/spine/AnimationState.c:		entry->listener(self, index, SP_ANIMATION_START, 0, 0);
spine-c/src/spine/AnimationState.c:		if (self->tracks[index] != entry) return;
spine-c/src/spine/AnimationState.c:	if (self->listener) self->listener(self, index, SP_ANIMATION_START, 0, 0);
spine-c/src/spine/AnimationState.c:	spAnimation* animation = spSkeletonData_findAnimation(self->data->skeletonData, animationName);
spine-c/src/spine/AnimationState.c:	if (current) _spAnimationState_disposeAllEntries(self, current->next);
spine-c/src/spine/AnimationState.c:	entry = internal->createTrackEntry(self);
spine-c/src/spine/AnimationState.c:	entry->animation = animation;
spine-c/src/spine/AnimationState.c:	entry->loop = loop;
spine-c/src/spine/AnimationState.c:	entry->endTime = animation->duration;
spine-c/src/spine/AnimationState.c:	spAnimation* animation = spSkeletonData_findAnimation(self->data->skeletonData, animationName);
spine-c/src/spine/AnimationState.c:	spTrackEntry* entry = internal->createTrackEntry(self);
spine-c/src/spine/AnimationState.c:	entry->animation = animation;
spine-c/src/spine/AnimationState.c:	entry->loop = loop;
spine-c/src/spine/AnimationState.c:	entry->endTime = animation->duration;
spine-c/src/spine/AnimationState.c:		while (last->next)
spine-c/src/spine/AnimationState.c:			last = last->next;
spine-c/src/spine/AnimationState.c:		last->next = entry;
spine-c/src/spine/AnimationState.c:		self->tracks[trackIndex] = entry;
spine-c/src/spine/AnimationState.c:			delay += last->endTime - spAnimationStateData_getMix(self->data, last->animation, animation);
spine-c/src/spine/AnimationState.c:	entry->delay = delay;
spine-c/src/spine/AnimationState.c:	if (trackIndex >= self->tracksCount) return 0;
spine-c/src/spine/AnimationState.c:	return self->tracks[trackIndex];
spine-c/src/spine/AnimationStateData.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/AnimationStateData.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/AnimationStateData.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/AnimationStateData.c:	self->animation = to;
spine-c/src/spine/AnimationStateData.c:	self->duration = duration;
spine-c/src/spine/AnimationStateData.c:	self->animation = from;
spine-c/src/spine/AnimationStateData.c:	CONST_CAST(spSkeletonData*, self->skeletonData) = skeletonData;
spine-c/src/spine/AnimationStateData.c:	_FromEntry* fromEntry = (_FromEntry*)self->entries;
spine-c/src/spine/AnimationStateData.c:		toEntry = fromEntry->toEntries;
spine-c/src/spine/AnimationStateData.c:			nextToEntry = toEntry->next;
spine-c/src/spine/AnimationStateData.c:		nextFromEntry = fromEntry->next;
spine-c/src/spine/AnimationStateData.c:	spAnimation* from = spSkeletonData_findAnimation(self->skeletonData, fromName);
spine-c/src/spine/AnimationStateData.c:	to = spSkeletonData_findAnimation(self->skeletonData, toName);
spine-c/src/spine/AnimationStateData.c:	_FromEntry* fromEntry = (_FromEntry*)self->entries;
spine-c/src/spine/AnimationStateData.c:		if (fromEntry->animation == from) {
spine-c/src/spine/AnimationStateData.c:			toEntry = fromEntry->toEntries;
spine-c/src/spine/AnimationStateData.c:				if (toEntry->animation == to) {
spine-c/src/spine/AnimationStateData.c:					toEntry->duration = duration;
spine-c/src/spine/AnimationStateData.c:				toEntry = toEntry->next;
spine-c/src/spine/AnimationStateData.c:		fromEntry = fromEntry->next;
spine-c/src/spine/AnimationStateData.c:		fromEntry->next = (_FromEntry*)self->entries;
spine-c/src/spine/AnimationStateData.c:		CONST_CAST(_FromEntry*, self->entries) = fromEntry;
spine-c/src/spine/AnimationStateData.c:	toEntry->next = fromEntry->toEntries;
spine-c/src/spine/AnimationStateData.c:	fromEntry->toEntries = toEntry;
spine-c/src/spine/AnimationStateData.c:	_FromEntry* fromEntry = (_FromEntry*)self->entries;
spine-c/src/spine/AnimationStateData.c:		if (fromEntry->animation == from) {
spine-c/src/spine/AnimationStateData.c:			_ToEntry* toEntry = fromEntry->toEntries;
spine-c/src/spine/AnimationStateData.c:				if (toEntry->animation == to) return toEntry->duration;
spine-c/src/spine/AnimationStateData.c:				toEntry = toEntry->next;
spine-c/src/spine/AnimationStateData.c:		fromEntry = fromEntry->next;
spine-c/src/spine/AnimationStateData.c:	return self->defaultMix;
spine-c/src/spine/SkeletonBounds.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/SkeletonBounds.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/SkeletonBounds.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SkeletonBounds.c:	self->capacity = capacity;
spine-c/src/spine/SkeletonBounds.c:	CONST_CAST(float*, self->vertices) = MALLOC(float, capacity);
spine-c/src/spine/SkeletonBounds.c:	FREE(self->vertices);
spine-c/src/spine/SkeletonBounds.c:	int prevIndex = self->count - 2;
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < self->count; i += 2) {
spine-c/src/spine/SkeletonBounds.c:		float vertexY = self->vertices[i + 1];
spine-c/src/spine/SkeletonBounds.c:		float prevY = self->vertices[prevIndex + 1];
spine-c/src/spine/SkeletonBounds.c:			float vertexX = self->vertices[i];
spine-c/src/spine/SkeletonBounds.c:			if (vertexX + (y - vertexY) / (prevY - vertexY) * (self->vertices[prevIndex] - vertexX) < x) inside = !inside;
spine-c/src/spine/SkeletonBounds.c:	float width12 = x1 - x2, height12 = y1 - y2;
spine-c/src/spine/SkeletonBounds.c:	float det1 = x1 * y2 - y1 * x2;
spine-c/src/spine/SkeletonBounds.c:	float x3 = self->vertices[self->count - 2], y3 = self->vertices[self->count - 1];
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < self->count; i += 2) {
spine-c/src/spine/SkeletonBounds.c:		float x4 = self->vertices[i], y4 = self->vertices[i + 1];
spine-c/src/spine/SkeletonBounds.c:		float det2 = x3 * y4 - y3 * x4;
spine-c/src/spine/SkeletonBounds.c:		float width34 = x3 - x4, height34 = y3 - y4;
spine-c/src/spine/SkeletonBounds.c:		float det3 = width12 * height34 - height12 * width34;
spine-c/src/spine/SkeletonBounds.c:		float x = (det1 * width34 - width12 * det2) / det3;
spine-c/src/spine/SkeletonBounds.c:			float y = (det1 * height34 - height12 * det2) / det3;
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < SUB_CAST(_spSkeletonBounds, self)->capacity; ++i)
spine-c/src/spine/SkeletonBounds.c:		if (self->polygons[i]) spPolygon_dispose(self->polygons[i]);
spine-c/src/spine/SkeletonBounds.c:	FREE(self->polygons);
spine-c/src/spine/SkeletonBounds.c:	FREE(self->boundingBoxes);
spine-c/src/spine/SkeletonBounds.c:	if (internal->capacity < skeleton->slotsCount) {
spine-c/src/spine/SkeletonBounds.c:		FREE(self->boundingBoxes);
spine-c/src/spine/SkeletonBounds.c:		self->boundingBoxes = MALLOC(spBoundingBoxAttachment*, skeleton->slotsCount);
spine-c/src/spine/SkeletonBounds.c:		newPolygons = CALLOC(spPolygon*, skeleton->slotsCount);
spine-c/src/spine/SkeletonBounds.c:		memcpy(newPolygons, self->polygons, internal->capacity);
spine-c/src/spine/SkeletonBounds.c:		FREE(self->polygons);
spine-c/src/spine/SkeletonBounds.c:		self->polygons = newPolygons;
spine-c/src/spine/SkeletonBounds.c:		internal->capacity = skeleton->slotsCount;
spine-c/src/spine/SkeletonBounds.c:	self->minX = (float)INT_MAX;
spine-c/src/spine/SkeletonBounds.c:	self->minY = (float)INT_MAX;
spine-c/src/spine/SkeletonBounds.c:	self->maxX = (float)INT_MIN;
spine-c/src/spine/SkeletonBounds.c:	self->maxY = (float)INT_MIN;
spine-c/src/spine/SkeletonBounds.c:	self->count = 0;
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < skeleton->slotsCount; ++i) {
spine-c/src/spine/SkeletonBounds.c:		spSlot* slot = skeleton->slots[i];
spine-c/src/spine/SkeletonBounds.c:		spAttachment* attachment = slot->attachment;
spine-c/src/spine/SkeletonBounds.c:		if (!attachment || attachment->type != SP_ATTACHMENT_BOUNDING_BOX) continue;
spine-c/src/spine/SkeletonBounds.c:		self->boundingBoxes[self->count] = boundingBox;
spine-c/src/spine/SkeletonBounds.c:		polygon = self->polygons[self->count];
spine-c/src/spine/SkeletonBounds.c:		if (!polygon || polygon->capacity < boundingBox->verticesCount) {
spine-c/src/spine/SkeletonBounds.c:			self->polygons[self->count] = polygon = spPolygon_create(boundingBox->verticesCount);
spine-c/src/spine/SkeletonBounds.c:		polygon->count = boundingBox->verticesCount;
spine-c/src/spine/SkeletonBounds.c:		spBoundingBoxAttachment_computeWorldVertices(boundingBox, slot->bone, polygon->vertices);
spine-c/src/spine/SkeletonBounds.c:			for (; ii < polygon->count; ii += 2) {
spine-c/src/spine/SkeletonBounds.c:				float x = polygon->vertices[ii];
spine-c/src/spine/SkeletonBounds.c:				float y = polygon->vertices[ii + 1];
spine-c/src/spine/SkeletonBounds.c:				if (x < self->minX) self->minX = x;
spine-c/src/spine/SkeletonBounds.c:				if (y < self->minY) self->minY = y;
spine-c/src/spine/SkeletonBounds.c:				if (x > self->maxX) self->maxX = x;
spine-c/src/spine/SkeletonBounds.c:				if (y > self->maxY) self->maxY = y;
spine-c/src/spine/SkeletonBounds.c:		self->count++;
spine-c/src/spine/SkeletonBounds.c:	return x >= self->minX && x <= self->maxX && y >= self->minY && y <= self->maxY;
spine-c/src/spine/SkeletonBounds.c:	if ((x1 <= self->minX && x2 <= self->minX) || (y1 <= self->minY && y2 <= self->minY) || (x1 >= self->maxX && x2 >= self->maxX)
spine-c/src/spine/SkeletonBounds.c:			|| (y1 >= self->maxY && y2 >= self->maxY)) return 0;
spine-c/src/spine/SkeletonBounds.c:	m = (y2 - y1) / (x2 - x1);
spine-c/src/spine/SkeletonBounds.c:	y = m * (self->minX - x1) + y1;
spine-c/src/spine/SkeletonBounds.c:	if (y > self->minY && y < self->maxY) return 1;
spine-c/src/spine/SkeletonBounds.c:	y = m * (self->maxX - x1) + y1;
spine-c/src/spine/SkeletonBounds.c:	if (y > self->minY && y < self->maxY) return 1;
spine-c/src/spine/SkeletonBounds.c:	x = (self->minY - y1) / m + x1;
spine-c/src/spine/SkeletonBounds.c:	if (x > self->minX && x < self->maxX) return 1;
spine-c/src/spine/SkeletonBounds.c:	x = (self->maxY - y1) / m + x1;
spine-c/src/spine/SkeletonBounds.c:	if (x > self->minX && x < self->maxX) return 1;
spine-c/src/spine/SkeletonBounds.c:	return self->minX < bounds->maxX && self->maxX > bounds->minX && self->minY < bounds->maxY && self->maxY > bounds->minY;
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < self->count; ++i)
spine-c/src/spine/SkeletonBounds.c:		if (spPolygon_containsPoint(self->polygons[i], x, y)) return self->boundingBoxes[i];
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < self->count; ++i)
spine-c/src/spine/SkeletonBounds.c:		if (spPolygon_intersectsSegment(self->polygons[i], x1, y1, x2, y2)) return self->boundingBoxes[i];
spine-c/src/spine/SkeletonBounds.c:	for (i = 0; i < self->count; ++i)
spine-c/src/spine/SkeletonBounds.c:		if (self->boundingBoxes[i] == boundingBox) return self->polygons[i];
spine-c/src/spine/Animation.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Animation.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Animation.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Animation.c:	MALLOC_STR(self->name, name);
spine-c/src/spine/Animation.c:	self->timelinesCount = timelinesCount;
spine-c/src/spine/Animation.c:	self->timelines = MALLOC(spTimeline*, timelinesCount);
spine-c/src/spine/Animation.c:	for (i = 0; i < self->timelinesCount; ++i)
spine-c/src/spine/Animation.c:		spTimeline_dispose(self->timelines[i]);
spine-c/src/spine/Animation.c:	FREE(self->timelines);
spine-c/src/spine/Animation.c:	FREE(self->name);
spine-c/src/spine/Animation.c:	int i, n = self->timelinesCount;
spine-c/src/spine/Animation.c:	if (loop && self->duration) {
spine-c/src/spine/Animation.c:		time = FMOD(time, self->duration);
spine-c/src/spine/Animation.c:		lastTime = FMOD(lastTime, self->duration);
spine-c/src/spine/Animation.c:		spTimeline_apply(self->timelines[i], skeleton, lastTime, time, events, eventsCount, 1);
spine-c/src/spine/Animation.c:	int i, n = self->timelinesCount;
spine-c/src/spine/Animation.c:	if (loop && self->duration) {
spine-c/src/spine/Animation.c:		time = FMOD(time, self->duration);
spine-c/src/spine/Animation.c:		lastTime = FMOD(lastTime, self->duration);
spine-c/src/spine/Animation.c:		spTimeline_apply(self->timelines[i], skeleton, lastTime, time, events, eventsCount, alpha);
spine-c/src/spine/Animation.c:	CONST_CAST(spTimelineType, self->type) = type;
spine-c/src/spine/Animation.c:	CONST_CAST(_spTimelineVtable*, self->vtable) = NEW(_spTimelineVtable);
spine-c/src/spine/Animation.c:	VTABLE(spTimeline, self)->dispose = dispose;
spine-c/src/spine/Animation.c:	VTABLE(spTimeline, self)->apply = apply;
spine-c/src/spine/Animation.c:	FREE(self->vtable);
spine-c/src/spine/Animation.c:	VTABLE(spTimeline, self)->dispose(self);
spine-c/src/spine/Animation.c:	VTABLE(spTimeline, self)->apply(self, skeleton, lastTime, time, firedEvents, eventsCount, alpha);
spine-c/src/spine/Animation.c:static const int BEZIER_SEGMENTS = 10, BEZIER_SIZE = 10 * 2 - 1;
spine-c/src/spine/Animation.c:	self->curves = CALLOC(float, (framesCount - 1) * BEZIER_SIZE);
spine-c/src/spine/Animation.c:	FREE(self->curves);
spine-c/src/spine/Animation.c:	self->curves[frameIndex * BEZIER_SIZE] = CURVE_LINEAR;
spine-c/src/spine/Animation.c:	self->curves[frameIndex * BEZIER_SIZE] = CURVE_STEPPED;
spine-c/src/spine/Animation.c:	float tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;
spine-c/src/spine/Animation.c:	int i = frameIndex * BEZIER_SIZE, n = i + BEZIER_SIZE - 1;
spine-c/src/spine/Animation.c:	self->curves[i++] = CURVE_BEZIER;
spine-c/src/spine/Animation.c:		self->curves[i] = x;
spine-c/src/spine/Animation.c:		self->curves[i + 1] = y;
spine-c/src/spine/Animation.c:	float type = self->curves[i];
spine-c/src/spine/Animation.c:	for (start = i, n = i + BEZIER_SIZE - 1; i < n; i += 2) {
spine-c/src/spine/Animation.c:		x = self->curves[i];
spine-c/src/spine/Animation.c:				prevX = self->curves[i - 2];
spine-c/src/spine/Animation.c:				prevY = self->curves[i - 1];
spine-c/src/spine/Animation.c:			return prevY + (self->curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
spine-c/src/spine/Animation.c:	y = self->curves[i - 1];
spine-c/src/spine/Animation.c:	return y + (1 - y) * (percent - x) / (1 - x); /* Last point is 1,1. */
spine-c/src/spine/Animation.c:	int high = valuesLength / step - 2;
spine-c/src/spine/Animation.c:	int high = valuesLength - 2;
spine-c/src/spine/Animation.c: int i, last = valuesLength - step;
spine-c/src/spine/Animation.c: return -1;
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount * frameSize;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, self->framesCount);
spine-c/src/spine/Animation.c:static const int ROTATE_PREV_FRAME_TIME = -2;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	bone = skeleton->bones[self->boneIndex];
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 2]) { /* Time is after last frame. */
spine-c/src/spine/Animation.c:		float amount = bone->data->rotation + self->frames[self->framesCount - 1] - bone->rotation;
spine-c/src/spine/Animation.c:			amount -= 360;
spine-c/src/spine/Animation.c:		while (amount < -180)
spine-c/src/spine/Animation.c:		bone->rotation += amount * alpha;
spine-c/src/spine/Animation.c:	frameIndex = binarySearch(self->frames, self->framesCount, time, 2);
spine-c/src/spine/Animation.c:	prevFrameValue = self->frames[frameIndex - 1];
spine-c/src/spine/Animation.c:	frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:	percent = 1 - (time - frameTime) / (self->frames[frameIndex + ROTATE_PREV_FRAME_TIME] - frameTime);
spine-c/src/spine/Animation.c:	percent = spCurveTimeline_getCurvePercent(SUPER(self), (frameIndex >> 1) - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:	amount = self->frames[frameIndex + ROTATE_FRAME_VALUE] - prevFrameValue;
spine-c/src/spine/Animation.c:		amount -= 360;
spine-c/src/spine/Animation.c:	while (amount < -180)
spine-c/src/spine/Animation.c:	amount = bone->data->rotation + (prevFrameValue + amount * percent) - bone->rotation;
spine-c/src/spine/Animation.c:		amount -= 360;
spine-c/src/spine/Animation.c:	while (amount < -180)
spine-c/src/spine/Animation.c:	bone->rotation += amount * alpha;
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 1] = angle;
spine-c/src/spine/Animation.c:static const int TRANSLATE_PREV_FRAME_TIME = -3;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	bone = skeleton->bones[self->boneIndex];
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 3]) { /* Time is after last frame. */
spine-c/src/spine/Animation.c:		bone->x += (bone->data->x + self->frames[self->framesCount - 2] - bone->x) * alpha;
spine-c/src/spine/Animation.c:		bone->y += (bone->data->y + self->frames[self->framesCount - 1] - bone->y) * alpha;
spine-c/src/spine/Animation.c:	frameIndex = binarySearch(self->frames, self->framesCount, time, 3);
spine-c/src/spine/Animation.c:	prevFrameX = self->frames[frameIndex - 2];
spine-c/src/spine/Animation.c:	prevFrameY = self->frames[frameIndex - 1];
spine-c/src/spine/Animation.c:	frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:	percent = 1 - (time - frameTime) / (self->frames[frameIndex + TRANSLATE_PREV_FRAME_TIME] - frameTime);
spine-c/src/spine/Animation.c:	percent = spCurveTimeline_getCurvePercent(SUPER(self), frameIndex / 3 - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:	bone->x += (bone->data->x + prevFrameX + (self->frames[frameIndex + TRANSLATE_FRAME_X] - prevFrameX) * percent - bone->x)
spine-c/src/spine/Animation.c:	bone->y += (bone->data->y + prevFrameY + (self->frames[frameIndex + TRANSLATE_FRAME_Y] - prevFrameY) * percent - bone->y)
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 1] = x;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 2] = y;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	bone = skeleton->bones[self->boneIndex];
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 3]) { /* Time is after last frame. */
spine-c/src/spine/Animation.c:		bone->scaleX += (bone->data->scaleX * self->frames[self->framesCount - 2] - bone->scaleX) * alpha;
spine-c/src/spine/Animation.c:		bone->scaleY += (bone->data->scaleY * self->frames[self->framesCount - 1] - bone->scaleY) * alpha;
spine-c/src/spine/Animation.c:	frameIndex = binarySearch(self->frames, self->framesCount, time, 3);
spine-c/src/spine/Animation.c:	prevFrameX = self->frames[frameIndex - 2];
spine-c/src/spine/Animation.c:	prevFrameY = self->frames[frameIndex - 1];
spine-c/src/spine/Animation.c:	frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:	percent = 1 - (time - frameTime) / (self->frames[frameIndex + TRANSLATE_PREV_FRAME_TIME] - frameTime);
spine-c/src/spine/Animation.c:	percent = spCurveTimeline_getCurvePercent(SUPER(self), frameIndex / 3 - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:	bone->scaleX += (bone->data->scaleX * (prevFrameX + (self->frames[frameIndex + TRANSLATE_FRAME_X] - prevFrameX) * percent)
spine-c/src/spine/Animation.c:			- bone->scaleX) * alpha;
spine-c/src/spine/Animation.c:	bone->scaleY += (bone->data->scaleY * (prevFrameY + (self->frames[frameIndex + TRANSLATE_FRAME_Y] - prevFrameY) * percent)
spine-c/src/spine/Animation.c:			- bone->scaleY) * alpha;
spine-c/src/spine/Animation.c:static const int COLOR_PREV_FRAME_TIME = -5;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 5]) {
spine-c/src/spine/Animation.c:		int i = self->framesCount - 1;
spine-c/src/spine/Animation.c:		r = self->frames[i - 3];
spine-c/src/spine/Animation.c:		g = self->frames[i - 2];
spine-c/src/spine/Animation.c:		b = self->frames[i - 1];
spine-c/src/spine/Animation.c:		a = self->frames[i];
spine-c/src/spine/Animation.c:		frameIndex = binarySearch(self->frames, self->framesCount, time, 5);
spine-c/src/spine/Animation.c:		prevFrameR = self->frames[frameIndex - 4];
spine-c/src/spine/Animation.c:		prevFrameG = self->frames[frameIndex - 3];
spine-c/src/spine/Animation.c:		prevFrameB = self->frames[frameIndex - 2];
spine-c/src/spine/Animation.c:		prevFrameA = self->frames[frameIndex - 1];
spine-c/src/spine/Animation.c:		frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:		percent = 1 - (time - frameTime) / (self->frames[frameIndex + COLOR_PREV_FRAME_TIME] - frameTime);
spine-c/src/spine/Animation.c:		percent = spCurveTimeline_getCurvePercent(SUPER(self), frameIndex / 5 - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:		r = prevFrameR + (self->frames[frameIndex + COLOR_FRAME_R] - prevFrameR) * percent;
spine-c/src/spine/Animation.c:		g = prevFrameG + (self->frames[frameIndex + COLOR_FRAME_G] - prevFrameG) * percent;
spine-c/src/spine/Animation.c:		b = prevFrameB + (self->frames[frameIndex + COLOR_FRAME_B] - prevFrameB) * percent;
spine-c/src/spine/Animation.c:		a = prevFrameA + (self->frames[frameIndex + COLOR_FRAME_A] - prevFrameA) * percent;
spine-c/src/spine/Animation.c:	slot = skeleton->slots[self->slotIndex];
spine-c/src/spine/Animation.c:		slot->r += (r - slot->r) * alpha;
spine-c/src/spine/Animation.c:		slot->g += (g - slot->g) * alpha;
spine-c/src/spine/Animation.c:		slot->b += (b - slot->b) * alpha;
spine-c/src/spine/Animation.c:		slot->a += (a - slot->a) * alpha;
spine-c/src/spine/Animation.c:		slot->r = r;
spine-c/src/spine/Animation.c:		slot->g = g;
spine-c/src/spine/Animation.c:		slot->b = b;
spine-c/src/spine/Animation.c:		slot->a = a;
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 1] = r;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 2] = g;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 3] = b;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 4] = a;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) {
spine-c/src/spine/Animation.c:		lastTime = -1;
spine-c/src/spine/Animation.c:	frameIndex = time >= self->frames[self->framesCount - 1] ?
spine-c/src/spine/Animation.c:		self->framesCount - 1 : binarySearch1(self->frames, self->framesCount, time) - 1;
spine-c/src/spine/Animation.c:	if (self->frames[frameIndex] < lastTime) return;
spine-c/src/spine/Animation.c:	attachmentName = self->attachmentNames[frameIndex];
spine-c/src/spine/Animation.c:	spSlot_setAttachment(skeleton->slots[self->slotIndex],
spine-c/src/spine/Animation.c:			attachmentName ? spSkeleton_getAttachmentForSlotIndex(skeleton, self->slotIndex, attachmentName) : 0);
spine-c/src/spine/Animation.c:	for (i = 0; i < self->framesCount; ++i)
spine-c/src/spine/Animation.c:		FREE(self->attachmentNames[i]);
spine-c/src/spine/Animation.c:	FREE(self->attachmentNames);
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(char**, self->attachmentNames) = CALLOC(char*, framesCount);
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	FREE(self->attachmentNames[frameIndex]);
spine-c/src/spine/Animation.c:		MALLOC_STR(self->attachmentNames[frameIndex], attachmentName);
spine-c/src/spine/Animation.c:		self->attachmentNames[frameIndex] = 0;
spine-c/src/spine/Animation.c:		lastTime = -1;
spine-c/src/spine/Animation.c:	} else if (lastTime >= self->frames[self->framesCount - 1]) /* Last time is after last frame. */
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	if (lastTime < self->frames[0])
spine-c/src/spine/Animation.c:		frameIndex = binarySearch1(self->frames, self->framesCount, lastTime);
spine-c/src/spine/Animation.c:		frame = self->frames[frameIndex];
spine-c/src/spine/Animation.c:			if (self->frames[frameIndex - 1] != frame) break;
spine-c/src/spine/Animation.c:			frameIndex--;
spine-c/src/spine/Animation.c:	for (; frameIndex < self->framesCount && time >= self->frames[frameIndex]; ++frameIndex) {
spine-c/src/spine/Animation.c:		firedEvents[*eventsCount] = self->events[frameIndex];
spine-c/src/spine/Animation.c:	for (i = 0; i < self->framesCount; ++i)
spine-c/src/spine/Animation.c:		spEvent_dispose(self->events[i]);
spine-c/src/spine/Animation.c:	FREE(self->events);
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(spEvent**, self->events) = CALLOC(spEvent*, framesCount);
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	FREE(self->events[frameIndex]);
spine-c/src/spine/Animation.c:	self->events[frameIndex] = event;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 1]) /* Time is after last frame. */
spine-c/src/spine/Animation.c:		frameIndex = self->framesCount - 1;
spine-c/src/spine/Animation.c:		frameIndex = binarySearch1(self->frames, self->framesCount, time) - 1;
spine-c/src/spine/Animation.c:	drawOrderToSetupIndex = self->drawOrders[frameIndex];
spine-c/src/spine/Animation.c:		memcpy(skeleton->drawOrder, skeleton->slots, self->slotsCount * sizeof(spSlot*));
spine-c/src/spine/Animation.c:		for (i = 0; i < self->slotsCount; ++i)
spine-c/src/spine/Animation.c:			skeleton->drawOrder[i] = skeleton->slots[drawOrderToSetupIndex[i]];
spine-c/src/spine/Animation.c:	for (i = 0; i < self->framesCount; ++i)
spine-c/src/spine/Animation.c:		FREE(self->drawOrders[i]);
spine-c/src/spine/Animation.c:	FREE(self->drawOrders);
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(int**, self->drawOrders) = CALLOC(int*, framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->slotsCount) = slotsCount;
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	FREE(self->drawOrders[frameIndex]);
spine-c/src/spine/Animation.c:		self->drawOrders[frameIndex] = 0;
spine-c/src/spine/Animation.c:		self->drawOrders[frameIndex] = MALLOC(int, self->slotsCount);
spine-c/src/spine/Animation.c:		memcpy(CONST_CAST(int*, self->drawOrders[frameIndex]), drawOrder, self->slotsCount * sizeof(int));
spine-c/src/spine/Animation.c:	spSlot *slot = skeleton->slots[self->slotIndex];
spine-c/src/spine/Animation.c:	if (slot->attachment != self->attachment) return;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	if (slot->attachmentVerticesCount < self->frameVerticesCount) {
spine-c/src/spine/Animation.c:		if (slot->attachmentVerticesCapacity < self->frameVerticesCount) {
spine-c/src/spine/Animation.c:			FREE(slot->attachmentVertices);
spine-c/src/spine/Animation.c:			slot->attachmentVertices = MALLOC(float, self->frameVerticesCount);
spine-c/src/spine/Animation.c:			slot->attachmentVerticesCapacity = self->frameVerticesCount;
spine-c/src/spine/Animation.c:	if (slot->attachmentVerticesCount != self->frameVerticesCount) alpha = 1; /* Don't mix from uninitialized slot vertices. */
spine-c/src/spine/Animation.c:	slot->attachmentVerticesCount = self->frameVerticesCount;
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 1]) {
spine-c/src/spine/Animation.c:		const float* lastVertices = self->frameVertices[self->framesCount - 1];
spine-c/src/spine/Animation.c:			for (i = 0; i < self->frameVerticesCount; ++i)
spine-c/src/spine/Animation.c:				slot->attachmentVertices[i] += (lastVertices[i] - slot->attachmentVertices[i]) * alpha;
spine-c/src/spine/Animation.c:			memcpy(slot->attachmentVertices, lastVertices, self->frameVerticesCount * sizeof(float));
spine-c/src/spine/Animation.c:	frameIndex = binarySearch1(self->frames, self->framesCount, time);
spine-c/src/spine/Animation.c:	frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:	percent = 1 - (time - frameTime) / (self->frames[frameIndex - 1] - frameTime);
spine-c/src/spine/Animation.c:	percent = spCurveTimeline_getCurvePercent(SUPER(self), frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:	prevVertices = self->frameVertices[frameIndex - 1];
spine-c/src/spine/Animation.c:	nextVertices = self->frameVertices[frameIndex];
spine-c/src/spine/Animation.c:		for (i = 0; i < self->frameVerticesCount; ++i) {
spine-c/src/spine/Animation.c:			slot->attachmentVertices[i] += (prev + (nextVertices[i] - prev) * percent - slot->attachmentVertices[i]) * alpha;
spine-c/src/spine/Animation.c:		for (i = 0; i < self->frameVerticesCount; ++i) {
spine-c/src/spine/Animation.c:			slot->attachmentVertices[i] = prev + (nextVertices[i] - prev) * percent;
spine-c/src/spine/Animation.c:	for (i = 0; i < self->framesCount; ++i)
spine-c/src/spine/Animation.c:		FREE(self->frameVertices[i]);
spine-c/src/spine/Animation.c:	FREE(self->frameVertices);
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, self->framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(float**, self->frameVertices) = CALLOC(float*, framesCount);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->frameVerticesCount) = frameVerticesCount;
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	FREE(self->frameVertices[frameIndex]);
spine-c/src/spine/Animation.c:		self->frameVertices[frameIndex] = 0;
spine-c/src/spine/Animation.c:		self->frameVertices[frameIndex] = MALLOC(float, self->frameVerticesCount);
spine-c/src/spine/Animation.c:		memcpy(CONST_CAST(float*, self->frameVertices[frameIndex]), vertices, self->frameVerticesCount * sizeof(float));
spine-c/src/spine/Animation.c:static const int IKCONSTRAINT_PREV_FRAME_TIME = -3;
spine-c/src/spine/Animation.c:static const int IKCONSTRAINT_PREV_FRAME_MIX = -2;
spine-c/src/spine/Animation.c:static const int IKCONSTRAINT_PREV_FRAME_BEND_DIRECTION = -1;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) return; /* Time is before first frame. */
spine-c/src/spine/Animation.c:	ikConstraint = skeleton->ikConstraints[self->ikConstraintIndex];
spine-c/src/spine/Animation.c:	if (time >= self->frames[self->framesCount - 3]) { /* Time is after last frame. */
spine-c/src/spine/Animation.c:		ikConstraint->mix += (self->frames[self->framesCount - 2] - ikConstraint->mix) * alpha;
spine-c/src/spine/Animation.c:		ikConstraint->bendDirection = (int)self->frames[self->framesCount - 1];
spine-c/src/spine/Animation.c:	frameIndex = binarySearch(self->frames, self->framesCount, time, 3);
spine-c/src/spine/Animation.c:	prevFrameMix = self->frames[frameIndex + IKCONSTRAINT_PREV_FRAME_MIX];
spine-c/src/spine/Animation.c:	frameTime = self->frames[frameIndex];
spine-c/src/spine/Animation.c:	percent = 1 - (time - frameTime) / (self->frames[frameIndex + IKCONSTRAINT_PREV_FRAME_TIME] - frameTime);
spine-c/src/spine/Animation.c:	percent = spCurveTimeline_getCurvePercent(SUPER(self), frameIndex / 3 - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));
spine-c/src/spine/Animation.c:	mix = prevFrameMix + (self->frames[frameIndex + IKCONSTRAINT_FRAME_MIX] - prevFrameMix) * percent;
spine-c/src/spine/Animation.c:	ikConstraint->mix += (mix - ikConstraint->mix) * alpha;
spine-c/src/spine/Animation.c:	ikConstraint->bendDirection = (int)self->frames[frameIndex + IKCONSTRAINT_PREV_FRAME_BEND_DIRECTION];
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 1] = mix;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 2] = (float)bendDirection;
spine-c/src/spine/Animation.c:	if (time < self->frames[0]) {
spine-c/src/spine/Animation.c:		lastTime = -1;
spine-c/src/spine/Animation.c:	frameIndex = (time >= self->frames[self->framesCount - 2] ?
spine-c/src/spine/Animation.c:		self->framesCount : binarySearch(self->frames, self->framesCount, time, 2)) - 2;
spine-c/src/spine/Animation.c:	if (self->frames[frameIndex] < lastTime) return;
spine-c/src/spine/Animation.c:	if (self->x)
spine-c/src/spine/Animation.c:		skeleton->bones[self->boneIndex]->flipX = (int)self->frames[frameIndex + 1];
spine-c/src/spine/Animation.c:		skeleton->bones[self->boneIndex]->flipY = (int)self->frames[frameIndex + 1];
spine-c/src/spine/Animation.c:	FREE(self->frames);
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->x) = x;
spine-c/src/spine/Animation.c:	CONST_CAST(int, self->framesCount) = framesCount << 1;
spine-c/src/spine/Animation.c:	CONST_CAST(float*, self->frames) = CALLOC(float, self->framesCount);
spine-c/src/spine/Animation.c:	self->frames[frameIndex] = time;
spine-c/src/spine/Animation.c:	self->frames[frameIndex + 1] = (float)flip;
spine-c/src/spine/SkinnedMeshAttachment.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/SkinnedMeshAttachment.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/SkinnedMeshAttachment.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->path);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->bones);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->weights);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->regionUVs);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->uvs);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->triangles);
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->edges);
spine-c/src/spine/SkinnedMeshAttachment.c:	self->r = 1;
spine-c/src/spine/SkinnedMeshAttachment.c:	self->g = 1;
spine-c/src/spine/SkinnedMeshAttachment.c:	self->b = 1;
spine-c/src/spine/SkinnedMeshAttachment.c:	self->a = 1;
spine-c/src/spine/SkinnedMeshAttachment.c:	float width = self->regionU2 - self->regionU, height = self->regionV2 - self->regionV;
spine-c/src/spine/SkinnedMeshAttachment.c:	FREE(self->uvs);
spine-c/src/spine/SkinnedMeshAttachment.c:	self->uvs = MALLOC(float, self->uvsCount);
spine-c/src/spine/SkinnedMeshAttachment.c:	if (self->regionRotate) {
spine-c/src/spine/SkinnedMeshAttachment.c:		for (i = 0; i < self->uvsCount; i += 2) {
spine-c/src/spine/SkinnedMeshAttachment.c:			self->uvs[i] = self->regionU + self->regionUVs[i + 1] * width;
spine-c/src/spine/SkinnedMeshAttachment.c:			self->uvs[i + 1] = self->regionV + height - self->regionUVs[i] * height;
spine-c/src/spine/SkinnedMeshAttachment.c:		for (i = 0; i < self->uvsCount; i += 2) {
spine-c/src/spine/SkinnedMeshAttachment.c:			self->uvs[i] = self->regionU + self->regionUVs[i] * width;
spine-c/src/spine/SkinnedMeshAttachment.c:			self->uvs[i + 1] = self->regionV + self->regionUVs[i + 1] * height;
spine-c/src/spine/SkinnedMeshAttachment.c:	float x = slot->bone->skeleton->x, y = slot->bone->skeleton->y;
spine-c/src/spine/SkinnedMeshAttachment.c:	spBone** skeletonBones = slot->bone->skeleton->bones;
spine-c/src/spine/SkinnedMeshAttachment.c:	if (slot->attachmentVerticesCount == 0) {
spine-c/src/spine/SkinnedMeshAttachment.c:		for (; v < self->bonesCount; w += 2) {
spine-c/src/spine/SkinnedMeshAttachment.c:			const int nn = self->bones[v] + v;
spine-c/src/spine/SkinnedMeshAttachment.c:				const spBone* bone = skeletonBones[self->bones[v]];
spine-c/src/spine/SkinnedMeshAttachment.c:				const float vx = self->weights[b], vy = self->weights[b + 1], weight = self->weights[b + 2];
spine-c/src/spine/SkinnedMeshAttachment.c:				wx += (vx * bone->m00 + vy * bone->m01 + bone->worldX) * weight;
spine-c/src/spine/SkinnedMeshAttachment.c:				wy += (vx * bone->m10 + vy * bone->m11 + bone->worldY) * weight;
spine-c/src/spine/SkinnedMeshAttachment.c:		const float* ffd = slot->attachmentVertices;
spine-c/src/spine/SkinnedMeshAttachment.c:		for (; v < self->bonesCount; w += 2) {
spine-c/src/spine/SkinnedMeshAttachment.c:			const int nn = self->bones[v] + v;
spine-c/src/spine/SkinnedMeshAttachment.c:				const spBone* bone = skeletonBones[self->bones[v]];
spine-c/src/spine/SkinnedMeshAttachment.c:				const float vx = self->weights[b] + ffd[f], vy = self->weights[b + 1] + ffd[f + 1], weight = self->weights[b + 2];
spine-c/src/spine/SkinnedMeshAttachment.c:				wx += (vx * bone->m00 + vy * bone->m01 + bone->worldX) * weight;
spine-c/src/spine/SkinnedMeshAttachment.c:				wy += (vx * bone->m10 + vy * bone->m11 + bone->worldY) * weight;
spine-c/src/spine/Slot.c: * Copyright (c) 2013-2015, Esoteric Software
spine-c/src/spine/Slot.c: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-c/src/spine/Slot.c: * non-transferable license to use, install, execute and perform the Spine
spine-c/src/spine/Slot.c:	CONST_CAST(spSlotData*, self->data) = data;
spine-c/src/spine/Slot.c:	CONST_CAST(spBone*, self->bone) = bone;
spine-c/src/spine/Slot.c:	FREE(self->attachmentVertices);
spine-c/src/spine/Slot.c:	if (attachment == self->attachment) return;
spine-c/src/spine/Slot.c:	CONST_CAST(spAttachment*, self->attachment) = attachment;
spine-c/src/spine/Slot.c:	SUB_CAST(_spSlot, self)->attachmentTime = self->bone->skeleton->time;
spine-c/src/spine/Slot.c:	self->attachmentVerticesCount = 0;
spine-c/src/spine/Slot.c:	SUB_CAST(_spSlot, self)->attachmentTime = self->bone->skeleton->time - time;
spine-c/src/spine/Slot.c:	return self->bone->skeleton->time - SUB_CAST(_spSlot, self) ->attachmentTime;
spine-c/src/spine/Slot.c:	self->r = self->data->r;
spine-c/src/spine/Slot.c:	self->g = self->data->g;
spine-c/src/spine/Slot.c:	self->b = self->data->b;
spine-c/src/spine/Slot.c:	self->a = self->data->a;
spine-c/src/spine/Slot.c:	if (!self->data->attachmentName)
spine-c/src/spine/Slot.c:		for (i = 0; i < self->bone->skeleton->data->slotsCount; ++i) {
spine-c/src/spine/Slot.c:			if (self->data == self->bone->skeleton->data->slots[i]) {
spine-c/src/spine/Slot.c:				attachment = spSkeleton_getAttachmentForSlotIndex(self->bone->skeleton, i, self->data->attachmentName);
spine-c/src/spine/Slot.c:		CONST_CAST(spAttachment*, self->attachment) = 0;
spine-sfml/src/spine/spine-sfml.h: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-sfml/src/spine/spine-sfml.h: * non-transferable license to install, execute and perform the Spine Runtimes
spine-sfml/src/spine/spine-sfml.cpp: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-sfml/src/spine/spine-sfml.cpp: * non-transferable license to install, execute and perform the Spine Runtimes
spine-sfml/src/spine/spine-sfml.cpp:#include <spine/spine-sfml.h>
spine-sfml/src/spine/spine-sfml.cpp:	//TextureID id=((spine::spineTexture*)self->rendererObject)->id;
spine-sfml/src/spine/spine-sfml.cpp:	//IRenderer::GetRendererInstance()->deleteTexture(id);
spine-sfml/src/spine/spine-sfml.cpp:	delete (Texture*)self->rendererObject;
spine-sfml/src/spine/spine-sfml.cpp:	vertexArray.resize(3*skeletonData->bonesCount * 4);
spine-sfml/src/spine/spine-sfml.cpp:    if (ownsAnimationStateData) AnimationStateData_dispose(state->data);
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->InitTex(IRenderer::GetRendererInstance()->GettexShader(),IRenderer::GetRendererInstance()->GettexVF());	
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setShader(IRenderer::GetRendererInstance()->GettexShader());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setVertexFormat(IRenderer::GetRendererInstance()->GettexVF());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setup2DMode(0, (float) IRenderer::GetRendererInstance()->GetViewportWidth(), 0, (float) IRenderer::GetRendererInstance()->GetViewportHeight());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setShaderConstant4f("scaleBias", IRenderer::GetRendererInstance()->GetscaleBias2D());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setShaderConstant4f("colorRGBA", D3DXFROMWINEVECTOR4(1.0f,1.0f,1.0f,1.0f));
spine-sfml/src/spine/spine-sfml.cpp:	//IRenderer::GetRendererInstance()->setShaderConstant1f("invertY", 1.0f);
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setTexture("Base", textureID);
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setBlendState(IRenderer::GetRendererInstance()->GetblendSrcAlpha());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->setDepthState(IRenderer::GetRendererInstance()->GetnoDepthTest());
spine-sfml/src/spine/spine-sfml.cpp:	//IRenderer::GetRendererInstance()->setBlendState(IRenderer::GetRendererInstance()->GetblendOneOne());
spine-sfml/src/spine/spine-sfml.cpp:	//IRenderer::GetRendererInstance()->setRasterizerState(IRenderer::GetRendererInstance()->GetcullBack());
spine-sfml/src/spine/spine-sfml.cpp:	IRenderer::GetRendererInstance()->DrawPrimitiveUP(aprim, nn, &avertexArray[0], &avertexArray[0], sizeof(PCTVertex));
spine-sfml/src/spine/spine-sfml.cpp:	float ViewportWidth=IRenderer::GetRendererInstance()->GetViewportWidth();
spine-sfml/src/spine/spine-sfml.cpp:	float ViewportHeight=IRenderer::GetRendererInstance()->GetViewportHeight();
spine-sfml/src/spine/spine-sfml.cpp:	for (int i = 0; i < skeleton->slotsCount; ++i) {
spine-sfml/src/spine/spine-sfml.cpp:		Slot* slot = skeleton->drawOrder[i];
spine-sfml/src/spine/spine-sfml.cpp:		Attachment* attachment = slot->attachment;
spine-sfml/src/spine/spine-sfml.cpp:		if (attachment->type == ATTACHMENT_REGION) {
spine-sfml/src/spine/spine-sfml.cpp:			sspineTexture = (spineTexture*)((AtlasRegion*)regionAttachment->rendererObject)->page->rendererObject;
spine-sfml/src/spine/spine-sfml.cpp:			RegionAttachment_computeWorldVertices(regionAttachment, slot->bone, worldVertices);
spine-sfml/src/spine/spine-sfml.cpp:			size.x=((spineTexture*)((AtlasRegion*)regionAttachment->rendererObject)->page->rendererObject)->width;
spine-sfml/src/spine/spine-sfml.cpp:			size.y=((spineTexture*)((AtlasRegion*)regionAttachment->rendererObject)->page->rendererObject)->height;
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 r = static_cast<Uint8>(skeleton->r * slot->r * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 g = static_cast<Uint8>(skeleton->g * slot->g * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 b = static_cast<Uint8>(skeleton->b * slot->b * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 a = static_cast<Uint8>(skeleton->a * slot->a * 255);
spine-sfml/src/spine/spine-sfml.cpp:			vertices[0].texCoord.x = regionAttachment->uvs[VERTEX_X1];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[0].texCoord.y = 1.0f-regionAttachment->uvs[VERTEX_Y1];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[1].texCoord.x = regionAttachment->uvs[VERTEX_X2];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[1].texCoord.y = 1.0f-regionAttachment->uvs[VERTEX_Y2];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[2].texCoord.x = regionAttachment->uvs[VERTEX_X3];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[2].texCoord.y = 1.0f-regionAttachment->uvs[VERTEX_Y3];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[3].texCoord.x = regionAttachment->uvs[VERTEX_X4];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:			vertices[3].texCoord.y = 1.0f-regionAttachment->uvs[VERTEX_Y4];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:			//vertexArray.resize(3*skeletonData->bonesCount * 4);
spine-sfml/src/spine/spine-sfml.cpp:		} else if (attachment->type == ATTACHMENT_MESH) {
spine-sfml/src/spine/spine-sfml.cpp:			if (mesh->verticesCount > SPINE_MESH_VERTEX_COUNT_MAX) continue;
spine-sfml/src/spine/spine-sfml.cpp:			sspineTexture = (spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject;
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 r = static_cast<Uint8>(skeleton->r * slot->r * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 g = static_cast<Uint8>(skeleton->g * slot->g * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 b = static_cast<Uint8>(skeleton->b * slot->b * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 a = static_cast<Uint8>(skeleton->a * slot->a * 255);
spine-sfml/src/spine/spine-sfml.cpp:			size.x=((spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject)->width;
spine-sfml/src/spine/spine-sfml.cpp:			size.y=((spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject)->height;
spine-sfml/src/spine/spine-sfml.cpp:			for (int i = 0; i < mesh->trianglesCount; ++i) {
spine-sfml/src/spine/spine-sfml.cpp:				int index = mesh->triangles[i] << 1;
spine-sfml/src/spine/spine-sfml.cpp:				vertex.texCoord.x = mesh->uvs[index];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:				vertex.texCoord.y = 1.0f-mesh->uvs[index + 1];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:				//vertexArray.resize(3*skeletonData->bonesCount * 4);
spine-sfml/src/spine/spine-sfml.cpp:		} else if (attachment->type == ATTACHMENT_SKINNED_MESH) {
spine-sfml/src/spine/spine-sfml.cpp:			if (mesh->uvsCount > SPINE_MESH_VERTEX_COUNT_MAX) continue;
spine-sfml/src/spine/spine-sfml.cpp:			sspineTexture = (spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject;
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 r = static_cast<Uint8>(skeleton->r * slot->r * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 g = static_cast<Uint8>(skeleton->g * slot->g * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 b = static_cast<Uint8>(skeleton->b * slot->b * 255);
spine-sfml/src/spine/spine-sfml.cpp:			Uint8 a = static_cast<Uint8>(skeleton->a * slot->a * 255);
spine-sfml/src/spine/spine-sfml.cpp:			size.x=((spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject)->width;
spine-sfml/src/spine/spine-sfml.cpp:			size.y=((spineTexture*)((AtlasRegion*)mesh->rendererObject)->page->rendererObject)->height;
spine-sfml/src/spine/spine-sfml.cpp:			for (int i = 0; i < mesh->trianglesCount; ++i) {
spine-sfml/src/spine/spine-sfml.cpp:				int index = mesh->triangles[i] << 1;
spine-sfml/src/spine/spine-sfml.cpp:				vertex.texCoord.x = mesh->uvs[index];// * size.x;
spine-sfml/src/spine/spine-sfml.cpp:				vertex.texCoord.y = 1.0f-mesh->uvs[index + 1];// * size.y;
spine-sfml/src/spine/spine-sfml.cpp:				//vertexArray.resize(3*skeletonData->bonesCount * 4);
spine-sfml/src/spine/spine-sfml.cpp:			//BlendStateID blend = slot->data->additiveBlending ? IRenderer::GetRendererInstance()->GetblendOneOne() : IRenderer::GetRendererInstance()->GetblendSrcAlpha();
spine-sfml/src/spine/spine-sfml.cpp:				if(nn) targetdraw(PRIM_TRIANGLES, nn, sspineTexture->id, vertexArray);//, states);
spine-sfml/src/spine/spine-sfml.cpp:	if(nn) targetdraw(PRIM_TRIANGLES, nn, statessspineTexture->id, vertexArray);//vertexArray, states);
spine-sfml/example/main.cpp: * You are granted a perpetual, non-exclusive, non-sublicensable and
spine-sfml/example/main.cpp: * non-transferable license to install, execute and perform the Spine Runtimes
spine-sfml/example/main.cpp:#include <spine/spine-sfml.h>
spine-sfml/example/main.cpp:	const char* animationName = (entry && entry->animation) ? entry->animation->name : 0;
spine-sfml/example/main.cpp:		//printf("%d event: %s, %s: %d, %f, %s\n", trackIndex, animationName, event->data->name, event->intValue, event->floatValue, event->stringValue);
spine-sfml/example/main.cpp:	json->scale = 0.6f;
spine-sfml/example/main.cpp:		printf("%s\n", json->error);
spine-sfml/example/main.cpp:	drawablespineboy->timeScale = 1;
spine-sfml/example/main.cpp:	Skeleton* skeleton = drawablespineboy->skeleton;
spine-sfml/example/main.cpp:	skeleton->flipX = false;
spine-sfml/example/main.cpp:	skeleton->flipY = false;
spine-sfml/example/main.cpp:	skeleton->x = 320;
spine-sfml/example/main.cpp:	skeleton->y = 460;
spine-sfml/example/main.cpp:	drawablespineboy->state->listener = callback;
spine-sfml/example/main.cpp:	AnimationState_setAnimationByName(drawablespineboy->state, 0, "walk", true);
spine-sfml/example/main.cpp:	sf::RenderWindow window(sf::VideoMode(640, 480), "Spine SFML - spineboy");
spine-sfml/example/main.cpp:			headSlot->g = 0;
spine-sfml/example/main.cpp:			headSlot->b = 0;
spine-sfml/example/main.cpp:			headSlot->g = 1;
spine-sfml/example/main.cpp:			headSlot->b = 1;
spine-sfml/example/main.cpp:		drawable->update(delta);
spine-sfml/example/main.cpp:		AnimationState_setAnimationByName(drawablespineboy->state, 0, "test", true);
spine-sfml/example/main.cpp:		AnimationState_setAnimationByName(drawablespineboy->state, 0, "walk", true);
spine-sfml/example/main.cpp:		AnimationState_addAnimationByName(drawablespineboy->state, 0, "jump", false, 3);
spine-sfml/example/main.cpp:		AnimationState_addAnimationByName(drawablespineboy->state, 0, "run", true, 0);
spine-sfml/example/main.cpp:	drawablespineboy->update(delta);		
spine-sfml/example/main.cpp:	drawablespineboy->draw();
spine-sfml/example/main.cpp:	filename.append("/spine/goblins/export/goblins-ffd.atlas");
spine-sfml/example/main.cpp:	json->scale = 1.4f;
spine-sfml/example/main.cpp:	filename.append("/spine/goblins/export/goblins-ffd.json");
spine-sfml/example/main.cpp:		printf("Error: %s\n", json->error);
spine-sfml/example/main.cpp:	drawablegoblins->timeScale = 1;
spine-sfml/example/main.cpp:	Skeleton* skeleton = drawablegoblins->skeleton;
spine-sfml/example/main.cpp:	skeleton->flipX = false;
spine-sfml/example/main.cpp:	skeleton->flipY = false;
spine-sfml/example/main.cpp:	skeleton->x = 320;
spine-sfml/example/main.cpp:	skeleton->y = 590;
spine-sfml/example/main.cpp:	AnimationState_setAnimationByName(drawablegoblins->state, 0, "walk", true);
spine-sfml/example/main.cpp:	sf::RenderWindow window(sf::VideoMode(640, 640), "Spine SFML - goblins");
spine-sfml/example/main.cpp:		drawable->update(delta);
spine-sfml/example/main.cpp:	drawablegoblins->update(delta);
spine-sfml/example/main.cpp:	drawablegoblins->draw();
spine-sfml/example/main.cpp:	json->scale = 0.5f;
spine-sfml/example/main.cpp:		printf("Error: %s\n", json->error);
spine-sfml/example/main.cpp:	drawableraptor->timeScale = 1;
spine-sfml/example/main.cpp:	Skeleton* skeleton = drawableraptor->skeleton;
spine-sfml/example/main.cpp:	skeleton->x = 320;
spine-sfml/example/main.cpp:	skeleton->y = 590;
spine-sfml/example/main.cpp:	AnimationState_setAnimationByName(drawableraptor->state, 0, "walk", true);
spine-sfml/example/main.cpp:	AnimationState_setAnimationByName(drawableraptor->state, 1, "empty", false);
spine-sfml/example/main.cpp:	AnimationState_addAnimationByName(drawableraptor->state, 1, "gungrab", false, 2);
spine-sfml/example/main.cpp:	sf::RenderWindow window(sf::VideoMode(640, 640), "Spine SFML - raptor");
spine-sfml/example/main.cpp:		drawable->update(delta);
spine-sfml/example/main.cpp:		AnimationState_setAnimationByName(drawableraptor->state, 0, "walk", true);
spine-sfml/example/main.cpp:		AnimationState_addAnimationByName(drawableraptor->state, 0, "empty", false, 3);
spine-sfml/example/main.cpp:		AnimationState_addAnimationByName(drawableraptor->state, 0, "gungrab", true, 0);
spine-sfml/example/main.cpp:	drawableraptor->update(delta);
spine-sfml/example/main.cpp:	drawableraptor->draw();
