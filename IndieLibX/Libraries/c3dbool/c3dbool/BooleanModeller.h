/*
  Copyright (c) 2018 Tommi Roenty   http://www.tommironty.fi/
  Licensed under The GNU Lesser General Public License, version 2.1:
      http://opensource.org/licenses/LGPL-2.1
*/
#ifndef __BooleanModeller_H__
#define __BooleanModeller_H__

#include "Vertex.h"
#include "Face.h"
#include "Solid.h"
#include "Bound.h"
#include "Segment.h"
#include "Object3D.h"
#include "Line.h"
inline bool contains(const std::vector<Point3d> av, const c3dbool_Vertex& a)
{
	for(unsigned int i=0;i<av.size();i++)
		if(av[i]==Point3d(a.x, a.y, a.z))
			return true;
	return false;
}
inline int indexOf(const std::vector<Point3d> av, const c3dbool_Vertex& a)
{
	for(unsigned int i=0;i<av.size();i++)
		if(av[i]==Point3d(a.x, a.y, a.z))
			return i;
	return -1;
}

/**
 * Class used to apply bool operations on solids.
 * 
 * <br><br>Two 'Solid' objects are submitted to this class constructor. There is a methods for 
 * each bool operation. Each of these return a 'Solid' resulting from the application
 * of its operation into the submitted solids. 
 *  
 * <br><br>See: D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes.  
 * "Constructive Solid Geometry for Polyhedral Objects" 
 * SIGGRAPH Proceedings, 1986, p.161.
 *  
 * @author Danilo Balby Silva Castanheira (danbalby@yahoo.com)
 */
class BooleanModeller : public Object
{
	/** solid where bool operations will be applied */
	Object3D object1, object2;
	
	//--------------------------------CONSTRUCTORS----------------------------------//
	
	/**
	 * Constructs a BooleanModeller object to apply bool operation in two solids. 
	 * Makes preliminary calculations 
	 * 
	 * @param solid1 first solid where bool operations will be applied
	 * @param solid2 second solid where bool operations will be applied
	 */	
	public:
	BooleanModeller(const BooleanModeller& rhs)
	{
		C3D_FNLN;
		object1=rhs.object1;
		object2=rhs.object2;
	}
	BooleanModeller() : Object()
	{
		C3D_FNLN;
		Solid solid1;
		Solid solid2;
		BooleanModeller(solid1, solid2);
	}
	BooleanModeller(Solid solid1, Solid solid2) : Object()
	{
		C3D_FNLN;

		//representation to apply bool operations
		object1 = Object3D(solid1);

		object2 = Object3D(solid2);

		
		//split the faces so that none of them intercepts each other
		object1.splitFaces(object2);

		object2.splitFaces(object1);

				
		//classify faces as being inside or outside the other solid
		object1.classifyFaces(object2);

		object2.classifyFaces(object1);

	}
	
	//----------------------------------OVERRIDES-----------------------------------//
	
	/**
	 * Clones the BooleanModeller object
	 * 
	 * @return cloned BooleanModeller object
	 */
	Object clone()
	{
		C3D_FNLN;
		//try
		{
			BooleanModeller clone;
			clone.object1 = object1;
			clone.object2 = object2;
			return clone;
		} /*
		catch(CloneNotSupportedException e)
		{	
			return 0;
		} */
	}
				
	//-------------------------------BOOLEAN_OPERATIONS-----------------------------//
	
	/**
	 * Gets the solid generated by the union of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the union of the two solids submitted to the constructor
	 */
	Solid getUnion() 
	{
		C3D_FNLN;
		return composeSolid(Face::eFace_OUTSIDE, Face::eFace_SAME, Face::eFace_OUTSIDE);
	}
	
	/**
	 * Gets the solid generated by the intersection of the two solids submitted to the constructor
	 * 
	 * @return solid generated by the intersection of the two solids submitted to the constructor.
	 * The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
	 * graph. To check this, use the Solid.isEmpty() method.
	 */
	Solid getIntersection()
	{
		C3D_FNLN;
		return composeSolid(Face::eFace_INSIDE, Face::eFace_SAME, Face::eFace_INSIDE);
	}
	
	/** Gets the solid generated by the difference of the two solids submitted to the constructor. 
	 * The fist solid is substracted by the second. 
	 * 
	 * @return solid generated by the difference of the two solids submitted to the constructor
	 */
	Solid getDifference()
	{
		C3D_FNLN;
		object2.invertInsideFaces();
		Solid result = composeSolid(Face::eFace_OUTSIDE, Face::eFace_OPPOSITE, Face::eFace_INSIDE);
		object2.invertInsideFaces();
		
		return result;
	}
	
	//--------------------------PRIVATES--------------------------------------------//
	
	/**
	 * Composes a solid based on the faces status of the two operators solids:
	 * Face::eFace_INSIDE, Face::eFace_OUTSIDE, Face::eFace_SAME, Face::eFace_OPPOSITE
	 * 
	 * @param faceStatus1 status expected for the first solid faces
	 * @param faceStatus2 other status expected for the first solid faces
	 * (expected a status for the faces coincident with second solid faces)
	 * @param faceStatus3 status expected for the second solid faces
	 */
	Solid composeSolid(int faceStatus1, int faceStatus2, int faceStatus3) 
	{
		C3D_FNLN;
		std::vector<Point3d> vertices;
		std::vector<__WORD__> indices;
		std::vector<Color3f> colors;
		
		//group the elements of the two solids whose faces fit with the desired status  
		groupObjectComponents(object1, vertices, indices, colors, faceStatus1, faceStatus2);
		groupObjectComponents(object2, vertices, indices, colors, faceStatus3, faceStatus3);
		
		//turn the arrayLists to arrays
		std::vector<Point3d> verticesArray(vertices.size());
		for(int i=0;i<vertices.size();i++)
		{
			verticesArray[i] = ((c3dbool_Vertex*)&vertices[i])->getPosition();
		}
		std::vector<__WORD__> indicesArray(indices.size());
		for(int i=0;i<indices.size();i++)
		{
			indicesArray[i] = *(__WORD__*)&indices[i];
		}
		std::vector<Color3f> colorsArray(colors.size());
		for(int i=0;i<colors.size();i++)
		{
			colorsArray[i] = *(Color3f*)&colors[i];
		}
		
		//returns the solid containing the grouped elements
		return Solid(verticesArray, indicesArray, colorsArray);
	}
	
	/**
	 * Fills solid arrays with data about faces of an object generated whose status
	 * is as required
	 * 
	 * @param object3d solid object used to fill the arrays
	 * @param vertices vertices array to be filled
	 * @param indices indices array to be filled
	 * @param colors colors array to be filled
	 * @param faceStatus1 a status expected for the faces used to to fill the data arrays
	 * @param faceStatus2 a status expected for the faces used to to fill the data arrays
	 */
	void groupObjectComponents(Object3D object, std::vector<Point3d> vertices, std::vector<__WORD__> indices, std::vector<Color3f> colors, int faceStatus1, int faceStatus2)
	{
		C3D_FNLN;
		Face face;
		//for each face..
		for(int i=0;i<object.getNumFaces();i++)
		{
			face = object.getFace(i);
			//if the face status fits with the desired status...
			if(face.getStatus()==faceStatus1 || face.getStatus()==faceStatus2)
			{
				//adds the face elements into the arrays 
				std::vector<c3dbool_Vertex> faceVerts;
				faceVerts.push_back(face.v1);
				faceVerts.push_back(face.v2);
				faceVerts.push_back(face.v3);
				for(int j=0;j<faceVerts.size();j++)
				{
					if(contains(vertices, faceVerts[j]))
					{
						indices.push_back(indexOf(vertices, faceVerts[j]));
					}
					else
					{
						indices.push_back(vertices.size()-1);
						vertices.push_back(D3DXFROMWINEVECTOR3(
							faceVerts[j].x,
							faceVerts[j].y,
							faceVerts[j].z
						));
						colors.push_back(faceVerts[j].getColor());
					}
				}
			}
		}
	}
};
#endif

